// This file is part of the Interface Reconstruction Library (IRL),
// a library for interface reconstruction and computational geometry operations.
//
// Copyright (C) 2022 Fabien Evrard <fa.evrard@gmail.com>
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

#ifndef IRL_GENERIC_CUTTING_PARABOLOID_INTERSECTION_MOMENT_CONTRIBUTIONS_TPP_
#define IRL_GENERIC_CUTTING_PARABOLOID_INTERSECTION_MOMENT_CONTRIBUTIONS_TPP_

#include <float.h>
#include <cassert>
#include <cmath>

#include "external/NumericalIntegration/NumericalIntegration.h"
#include "irl/data_structures/small_vector.h"
#include "irl/data_structures/stack_vector.h"
#include "irl/generic_cutting/half_edge_cutting/half_edge_cutting_helpers.h"
#include "irl/geometry/general/normal.h"
#include "irl/geometry/general/pt.h"
#include "irl/geometry/general/reference_frame.h"
#include "irl/geometry/general/rotations.h"
#include "irl/geometry/general/scalar_with_gradient.h"
#include "irl/geometry/general/unit_quaternion.h"
#include "irl/helpers/mymath.h"
#include "irl/paraboloid_reconstruction/paraboloid.h"

namespace IRL {

template <class ScalarType, UnsignedIndex_t Order>
const std::array<ScalarType, Order> AbscissaeGauss(void) {
  if constexpr (Order == 5) {
    return std::array<ScalarType, Order>(
        {ScalarType(0),
         ScalarType(
             -0.5384693101056830910363144207002088049672866069055599562022316270594711853677552910358036672505709315713670572321043495510816912158744046420683486075627481533978123828583369317846132387526796166796502053799563629878671716361660767584852200097418079241406256057571019602720019270523093750336),
         ScalarType(
             0.5384693101056830910363144207002088049672866069055599562022316270594711853677552910358036672505709315713670572321043495510816912158744046420683486075627481533978123828583369317846132387526796166796502053799563629878671716361660767584852200097418079241406256057571019602720019270523093750336),
         ScalarType(
             -0.9061798459386639927976268782993929651256519107625308628737622865437707949166868469411429895535422619115836248167051160932020660084349721915374869570125418659061700540273012086530604091207821562942704193786707298217315368769002376029537907738935528847397895557648103916797868140600953498906),
         ScalarType(
             0.9061798459386639927976268782993929651256519107625308628737622865437707949166868469411429895535422619115836248167051160932020660084349721915374869570125418659061700540273012086530604091207821562942704193786707298217315368769002376029537907738935528847397895557648103916797868140600953498906)});
  } else if constexpr (Order == 50) {
    return std::
        array<ScalarType,
              Order>({ScalarType(
                          -0.0310983383271888761123289896659491942472962229599980429747962356620305239606004565028047384756036743609342213054916932164258131193040411751026920689241449011097193178455222668065986763613933471614816223861172742872735315854546459495291942313151871872131180410409964578036057942486779145999),
                      ScalarType(
                          0.0310983383271888761123289896659491942472962229599980429747962356620305239606004565028047384756036743609342213054916932164258131193040411751026920689241449011097193178455222668065986763613933471614816223861172742872735315854546459495291942313151871872131180410409964578036057942486779145999),
                      ScalarType(
                          -0.0931747015600861408544503776396003478856713839221386146828891556461802516674295107179672198298784688901653049792063891285161907411935710988161659353070912475552745379285159612966725856043762887770393250006529115742102585653286033650783364904729767419897102113013850780637334748895180766148),
                      ScalarType(
                          0.0931747015600861408544503776396003478856713839221386146828891556461802516674295107179672198298784688901653049792063891285161907411935710988161659353070912475552745379285159612966725856043762887770393250006529115742102585653286033650783364904729767419897102113013850780637334748895180766148),
                      ScalarType(
                          -0.1548905899981459020716286209411095012018502200549376323967303263535578248323610939527290673193556208942496733933139171111540496120153679896445246556537339604612859252206782877782641209825926825157887271492506356092759283658366551226302165747715092608324835604075651546089215707666800199163),
                      ScalarType(0.1548905899981459020716286209411095012018502200549376323967303263535578248323610939527290673193556208942496733933139171111540496120153679896445246556537339604612859252206782877782641209825926825157887271492506356092759283658366551226302165747715092608324835604075651546089215707666800199163),
                      ScalarType(
                          -0.2160072368760417568472845326171013337057559725101332727036211263619901938350004687445286661319291794064580451138376184642327027227845452915036133761630496235920939213563307856173950186022147749415427485165406683776942667262672110823564317650976728334189578624108122074277516104858015265246),
                      ScalarType(
                          0.2160072368760417568472845326171013337057559725101332727036211263619901938350004687445286661319291794064580451138376184642327027227845452915036133761630496235920939213563307856173950186022147749415427485165406683776942667262672110823564317650976728334189578624108122074277516104858015265246),
                      ScalarType(
                          -0.2762881937795319903276452785211301857148015871319961506135055794383769236196981027633040616238063303466132601081904590994370379660824771939021847203146564102074359612078560657474242541077466168948230410549367539428578772936515014388114362317612148717284148806206383497327446587408084245254),
                      ScalarType(
                          0.2762881937795319903276452785211301857148015871319961506135055794383769236196981027633040616238063303466132601081904590994370379660824771939021847203146564102074359612078560657474242541077466168948230410549367539428578772936515014388114362317612148717284148806206383497327446587408084245254),
                      ScalarType(
                          -0.3355002454194373568369882572910716978412185930367957619004305397109861948253310226160694958026607226807878236147924457729558433971162345789732848207721523269734048412559476552838958941996511917968725969211179228961225704987759400132094253259757639678020017328166747459335022612704082064973),
                      ScalarType(
                          0.3355002454194373568369882572910716978412185930367957619004305397109861948253310226160694958026607226807878236147924457729558433971162345789732848207721523269734048412559476552838958941996511917968725969211179228961225704987759400132094253259757639678020017328166747459335022612704082064973),
                      ScalarType(
                          -0.3934143118975651273942292538238172702461394686726560030790366208564977281243987699606861202733329910632711185067193327834436164543144718154962665382568598316578061708483274869831275077690614757554582193762851478757468247983390332863339488918337020846612195743013962590561058936806898562661),
                      ScalarType(
                          0.3934143118975651273942292538238172702461394686726560030790366208564977281243987699606861202733329910632711185067193327834436164543144718154962665382568598316578061708483274869831275077690614757554582193762851478757468247983390332863339488918337020846612195743013962590561058936806898562661),
                      ScalarType(
                          -0.4498063349740387891471314677783758173150645134651736659414806698859708536989042214873355910644272276669887846423613574480568092964732835178367006355710221603442066614927023096798438098964248040996669064693461531068957595760451247362275493393367318680428031480081377433126360358777391395998),
                      ScalarType(
                          0.4498063349740387891471314677783758173150645134651736659414806698859708536989042214873355910644272276669887846423613574480568092964732835178367006355710221603442066614927023096798438098964248040996669064693461531068957595760451247362275493393367318680428031480081377433126360358777391395998),
                      ScalarType(
                          -0.504458144907464201651459131849141192635378678270679238182739210968226378693932598787000137183296006514821308242716698423477699127370412350838521709324119082047874319857659886566562444050130928440690271219326726744700735075752319170458506447082463711955712381417719713447119561096434748921),
                      ScalarType(
                          0.504458144907464201651459131849141192635378678270679238182739210968226378693932598787000137183296006514821308242716698423477699127370412350838521709324119082047874319857659886566562444050130928440690271219326726744700735075752319170458506447082463711955712381417719713447119561096434748921),
                      ScalarType(
                          -0.5571583045146500543155229096258016078158983822377502613164614867604894521887321767073612986839087455344605756084827067563266351029331009722084475685718333426314216836101809669035926062249352713312736423741618907753546821912336807924207446619903002126974566647473194379477112664991003319013),
                      ScalarType(
                          0.5571583045146500543155229096258016078158983822377502613164614867604894521887321767073612986839087455344605756084827067563266351029331009722084475685718333426314216836101809669035926062249352713312736423741618907753546821912336807924207446619903002126974566647473194379477112664991003319013),
                      ScalarType(
                          -0.6077029271849502391803817963918328936042050206759943557121311889396856476834209221465869800317154224441747118261375858195273700386258803121371756998408139494120489716878706661103811563337304371670332259134160387119570729079580554433943242255391556852788523492219849110642761070865002587912),
                      ScalarType(
                          0.6077029271849502391803817963918328936042050206759943557121311889396856476834209221465869800317154224441747118261375858195273700386258803121371756998408139494120489716878706661103811563337304371670332259134160387119570729079580554433943242255391556852788523492219849110642761070865002587912),
                      ScalarType(
                          -0.6558964656854393607816248640036798190414105283823318265309345913921084785807517624649539530178704352004452729615913202721064660196638286797403734879943564470340604041349987558699200324066849818623859895871432880070030373598333045564767173322028951327862572831127021899017357155925903737838),
                      ScalarType(
                          0.6558964656854393607816248640036798190414105283823318265309345913921084785807517624649539530178704352004452729615913202721064660196638286797403734879943564470340604041349987558699200324066849818623859895871432880070030373598333045564767173322028951327862572831127021899017357155925903737838),
                      ScalarType(
                          -0.701552468706822251089546257883655728149719228484695642740924379033292245834595296968157771841325078726136162664153259904144212903342310629548357630033372348513424972364316245342111571459428734837074928138207892303042980064003860224900347038608352543015451218397463935272874134518185060138),
                      ScalarType(
                          0.701552468706822251089546257883655728149719228484695642740924379033292245834595296968157771841325078726136162664153259904144212903342310629548357630033372348513424972364316245342111571459428734837074928138207892303042980064003860224900347038608352543015451218397463935272874134518185060138),
                      ScalarType(
                          -0.7444943022260685382605362526821942428701879313295845785247791479329297913088695200494981098607466747245861939548355027718421268656716257290263134609150248533217038449076341003667546323902938700921530218888076131308142373788956223099062529656228422280639027085512055244834293207625522222826),
                      ScalarType(
                          0.7444943022260685382605362526821942428701879313295845785247791479329297913088695200494981098607466747245861939548355027718421268656716257290263134609150248533217038449076341003667546323902938700921530218888076131308142373788956223099062529656228422280639027085512055244834293207625522222826),
                      ScalarType(
                          -0.7845558329003992639053051963409912008473162725564443527388591218931310203939999876847130857580782518424642260617197703766591358582279888423126974706276315111724646202999470416014104562581832010014309664248196010603302257892440327966687541854603566804414574590353056199413480291149032024371),
                      ScalarType(0.7845558329003992639053051963409912008473162725564443527388591218931310203939999876847130857580782518424642260617197703766591358582279888423126974706276315111724646202999470416014104562581832010014309664248196010603302257892440327966687541854603566804414574590353056199413480291149032024371),
                      ScalarType(
                          -0.8215820708593359483562541108739395377607413833434857485233744606154686656061347179924886450651287164363938793872891125416083125692290421753100014219969580607305029232964083857010379335138953146284848148616331836175384084113157158870563781334333290808364508605719404678719441659157143947045),
                      ScalarType(
                          0.8215820708593359483562541108739395377607413833434857485233744606154686656061347179924886450651287164363938793872891125416083125692290421753100014219969580607305029232964083857010379335138953146284848148616331836175384084113157158870563781334333290808364508605719404678719441659157143947045),
                      ScalarType(
                          -0.8554297694299460846113626439347574676548330394869059634383299203413186300718576442191105257369901333121963699477590765744676048431253014560972726386291522674864852925977467110232998454322408267820517228518799830494233636784985399721186517405243964807837218974584122696958479526279501024415),
                      ScalarType(
                          0.8554297694299460846113626439347574676548330394869059634383299203413186300718576442191105257369901333121963699477590765744676048431253014560972726386291522674864852925977467110232998454322408267820517228518799830494233636784985399721186517405243964807837218974584122696958479526279501024415),
                      ScalarType(
                          -0.8859679795236130486375409824667536341942903107558083624465571396548873258374075451665011758623680195570790805844392859685927635339476448831827473992735226109842958846888451928332897692737189856147457408243157863998772688300129008402899329273738955916734897929675350359484720954221020488749),
                      ScalarType(
                          0.8859679795236130486375409824667536341942903107558083624465571396548873258374075451665011758623680195570790805844392859685927635339476448831827473992735226109842958846888451928332897692737189856147457408243157863998772688300129008402899329273738955916734897929675350359484720954221020488749),
                      ScalarType(
                          -0.9130785566557918930897356427716570947841881916977823896227265532008524340106515562802471052150034141823396018998546244787883064826080188436358794452751373955836413977386435676539280267310369010028007946850039115385098841799551970875864682796624717556307675548536659706857477009313402727761),
                      ScalarType(
                          0.9130785566557918930897356427716570947841881916977823896227265532008524340106515562802471052150034141823396018998546244787883064826080188436358794452751373955836413977386435676539280267310369010028007946850039115385098841799551970875864682796624717556307675548536659706857477009313402727761),
                      ScalarType(
                          -0.9366566189448779337808749472724966021537315980952029223750542738093561312349230344186141970738167340957460443866430218553110098870570420758610694406736849993444774254524097383322189015590186704910198301469255069298454429840434221690957122354892307183728397378528625778598142045490544697097),
                      ScalarType(
                          0.9366566189448779337808749472724966021537315980952029223750542738093561312349230344186141970738167340957460443866430218553110098870570420758610694406736849993444774254524097383322189015590186704910198301469255069298454429840434221690957122354892307183728397378528625778598142045490544697097),
                      ScalarType(
                          -0.9566109552428079429977456441566220940514341246260465428559790829730553062968089391204525732104352388312934367488954182758273304734605586122506583424141721602478444493744490912578765462498496947314992010522126985600781923767493689117116481606317787989709607049847921859143187366377294068808),
                      ScalarType(
                          0.9566109552428079429977456441566220940514341246260465428559790829730553062968089391204525732104352388312934367488954182758273304734605586122506583424141721602478444493744490912578765462498496947314992010522126985600781923767493689117116481606317787989709607049847921859143187366377294068808),
                      ScalarType(
                          -0.9728643851066920737133441046062520536691734070499542017450962752256767189858167889175439147194338156258543588356514485569836759662340193287869213571961760422781169890315959462975774268191429514424463531413225833324782481432099303839501586907427025421341402079057930425214259527474481878185),
                      ScalarType(
                          0.9728643851066920737133441046062520536691734070499542017450962752256767189858167889175439147194338156258543588356514485569836759662340193287869213571961760422781169890315959462975774268191429514424463531413225833324782481432099303839501586907427025421341402079057930425214259527474481878185),
                      ScalarType(
                          -0.9853540840480058823090096256324894040155926309454058087178092210085350814702507706567935357988693084717360048777592529211975482976200999138335922151355075742278279079281583409637063122367381643367228428984092208210957974909616473382012915336331607687807533058908419636635757430236892192287),
                      ScalarType(
                          0.9853540840480058823090096256324894040155926309454058087178092210085350814702507706567935357988693084717360048777592529211975482976200999138335922151355075742278279079281583409637063122367381643367228428984092208210957974909616473382012915336331607687807533058908419636635757430236892192287),
                      ScalarType(
                          -0.9940319694320907125851082004206947281574779710683235903365247891159333102441986200847502032997488182597606600945459419958549215257107600909497912431076196464989212967891293626057814097833081516374703513635326134819095701676989809941280809053034462502697330311898546802092693406276002055604),
                      ScalarType(
                          0.9940319694320907125851082004206947281574779710683235903365247891159333102441986200847502032997488182597606600945459419958549215257107600909497912431076196464989212967891293626057814097833081516374703513635326134819095701676989809941280809053034462502697330311898546802092693406276002055604),
                      ScalarType(
                          -0.9988664044200710501854594449742185059962435129040785251770386176575391083082719606000817676304540908816211142125746246395146062751602721269012718747075215374285691593278562767853983187135230076747980429953846819229059201451936042829796424039633265927034501611175851432195329432234117877341),
                      ScalarType(
                          0.9988664044200710501854594449742185059962435129040785251770386176575391083082719606000817676304540908816211142125746246395146062751602721269012718747075215374285691593278562767853983187135230076747980429953846819229059201451936042829796424039633265927034501611175851432195329432234117877341)});
  }
}

template <class ScalarType, UnsignedIndex_t Order>
const std::array<ScalarType, Order> WeightsGauss(void) {
  if constexpr (Order == 5) {
    return std::
        array<
            ScalarType,
            Order>({ScalarType(
                        0.5688888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888889),
                    ScalarType(
                        0.4786286704993664680412915148356381929122955533431415399727276673338382671525124569755621250616041107794464209474122299742927901670531874220236019762755381069981020199559708433435017355341690324695622104863536721598859262913644828482640505637133513606531929893286127565185389732581634388813),
                    ScalarType(0.4786286704993664680412915148356381929122955533431415399727276673338382671525124569755621250616041107794464209474122299742927901670531874220236019762755381069981020199559708433435017355341690324695622104863536721598859262913644828482640505637133513606531929893286127565185389732581634388813), ScalarType(0.2369268850561890875142640407199173626432600022124140155828278882217172884030430985799934304939514447761091346081433255812627653885023681335319535792800174485574535355995847122120538200213865230859933450692018833956696292641910727072915049918422041949023625662269427990370165822973921166843), ScalarType(0.2369268850561890875142640407199173626432600022124140155828278882217172884030430985799934304939514447761091346081433255812627653885023681335319535792800174485574535355995847122120538200213865230859933450692018833956696292641910727072915049918422041949023625662269427990370165822973921166843)});
  } else if constexpr (Order == 50) {
    return std::
        array<ScalarType,
              Order>({ScalarType(
                          0.0621766166553472623210331073606134308676824692010266331011656376197576116005161496153965234256251945035190878538514646027013624173900556610838761659666942055109367824940206833480509708770585965856278059828616376291100636294863879189012831678201204004108488665741182142651742559639551734037),
                      ScalarType(
                          0.0621766166553472623210331073606134308676824692010266331011656376197576116005161496153965234256251945035190878538514646027013624173900556610838761659666942055109367824940206833480509708770585965856278059828616376291100636294863879189012831678201204004108488665741182142651742559639551734037),
                      ScalarType(
                          0.0619360674206832433840875097808306885728770566912449049427597061169548212868868663541874012601839334985088784270698064309969541498088869067871658103239608498898570222942039787789491100273928863404949851014677414818424352394725004762435803560633359022843198264104954032099529619257259491801),
                      ScalarType(
                          0.0619360674206832433840875097808306885728770566912449049427597061169548212868868663541874012601839334985088784270698064309969541498088869067871658103239608498898570222942039787789491100273928863404949851014677414818424352394725004762435803560633359022843198264104954032099529619257259491801),
                      ScalarType(
                          0.0614558995903166637564067860839153750972675757640075143092240503590591099522169672748200364437562204885807990970763029249537758507233212237017742284844183388808291922833760284738758450117061649994572963447806753613201097620387227379616502864895473076255186860857337328863552346319006579831),
                      ScalarType(0.0614558995903166637564067860839153750972675757640075143092240503590591099522169672748200364437562204885807990970763029249537758507233212237017742284844183388808291922833760284738758450117061649994572963447806753613201097620387227379616502864895473076255186860857337328863552346319006579831),
                      ScalarType(
                          0.0607379708417702160317500153848110016097992732354035357231967745617595765171250534312181750296374263128879019092782305080557064856348434408055005766902937540177876396530061691581507402968423487639092501934532702439761390506498453609601806061350696178237290197888702751499183627828908402727),
                      ScalarType(
                          0.0607379708417702160317500153848110016097992732354035357231967745617595765171250534312181750296374263128879019092782305080557064856348434408055005766902937540177876396530061691581507402968423487639092501934532702439761390506498453609601806061350696178237290197888702751499183627828908402727),
                      ScalarType(
                          0.0597850587042654575095764053125852307966660420726690045852419788036192214142032773895684201637879463019262072380031466476567220929846354621807808797175608715872823266008581920669925958405350260637422098766570723624719697799240929217940484053449893456571504673198080898063777197662458641641),
                      ScalarType(
                          0.0597850587042654575095764053125852307966660420726690045852419788036192214142032773895684201637879463019262072380031466476567220929846354621807808797175608715872823266008581920669925958405350260637422098766570723624719697799240929217940484053449893456571504673198080898063777197662458641641),
                      ScalarType(
                          0.0586008498132224458351224366308484662097675134440254733132503424753544800506010023534917402823387735713487722160695308103736016013598877502341407681854271828711140153510988037511037581064245169313459924938540820035525160696902589953067412036754296845157116278286705995866817148389552326749),
                      ScalarType(0.0586008498132224458351224366308484662097675134440254733132503424753544800506010023534917402823387735713487722160695308103736016013598877502341407681854271828711140153510988037511037581064245169313459924938540820035525160696902589953067412036754296845157116278286705995866817148389552326749),
                      ScalarType(
                          0.0571899256477283837230293150659931630115753722570917549368537813528049256668563831914853051327519838343266837277662399801237849491243357879685587847939246168190354707776779534518066772752353854076858916160306814778908970118801094130377959554891723025464423995945639001222807895668961759585),
                      ScalarType(
                          0.0571899256477283837230293150659931630115753722570917549368537813528049256668563831914853051327519838343266837277662399801237849491243357879685587847939246168190354707776779534518066772752353854076858916160306814778908970118801094130377959554891723025464423995945639001222807895668961759585),
                      ScalarType(
                          0.0555577448062125176235674256122694975951352999839026758171727785103185507145957318820639368998658383891702034680656404642584182170695551545892155693846318189390209831617210201856838868147573364357753897444101398300478442200366082264079846351201406914825288748851048678390818799658442894729),
                      ScalarType(
                          0.0555577448062125176235674256122694975951352999839026758171727785103185507145957318820639368998658383891702034680656404642584182170695551545892155693846318189390209831617210201856838868147573364357753897444101398300478442200366082264079846351201406914825288748851048678390818799658442894729),
                      ScalarType(
                          0.0537106218889962465234587972556645527680232135299221530458999991815965161756756795399811463890559716706390607630333580513802468065310049578003524120769795024923001794565883709570478049199582519196957329760304489224976006321620359421219668709500097205487235850716303396776885970216050912557),
                      ScalarType(
                          0.0537106218889962465234587972556645527680232135299221530458999991815965161756756795399811463890559716706390607630333580513802468065310049578003524120769795024923001794565883709570478049199582519196957329760304489224976006321620359421219668709500097205487235850716303396776885970216050912557),
                      ScalarType(
                          0.051655703069581138489905295840095279649825449395439645099533186451192177308562865499955919291070998211945733531087230536398905174851121913358052847034832206892197271597775815649283122380044945707302272504442068639373167689486624061693252223663913029869902342770952016571975414683435427402),
                      ScalarType(
                          0.051655703069581138489905295840095279649825449395439645099533186451192177308562865499955919291070998211945733531087230536398905174851121913358052847034832206892197271597775815649283122380044945707302272504442068639373167689486624061693252223663913029869902342770952016571975414683435427402),
                      ScalarType(
                          0.0494009384494663149212435807514327286922870509666131247921235602480698457058893934855742576111012442758806751884673539284143694774538910767598530854628612574565368779513275794147215370869906758615264094416837517423065027140919758686756919254935943043547824194682360399426732716524246141873),
                      ScalarType(
                          0.0494009384494663149212435807514327286922870509666131247921235602480698457058893934855742576111012442758806751884673539284143694774538910767598530854628612574565368779513275794147215370869906758615264094416837517423065027140919758686756919254935943043547824194682360399426732716524246141873),
                      ScalarType(
                          0.04695505130394843296563301363498768251406430618605272996580427934336506071982918321772533927803330418127148266353891891730783028024995970407779511688495011833925704858010176705373000480130282972264414250145548002275950628487927461806121308391093406752752302136584048644405426398807886424),
                      ScalarType(0.04695505130394843296563301363498768251406430618605272996580427934336506071982918321772533927803330418127148266353891891730783028024995970407779511688495011833925704858010176705373000480130282972264414250145548002275950628487927461806121308391093406752752302136584048644405426398807886424),
                      ScalarType(
                          0.0443275043388032754920222868303941974607612983554531656632319068276227294714772828508214754531825733608057601420433182446740997664319779818997585520416813922459267355934426368607473489745720599652869554865615372043424853098967308046422295118461130471747696561564617535249767562911218564247),
                      ScalarType(
                          0.0443275043388032754920222868303941974607612983554531656632319068276227294714772828508214754531825733608057601420433182446740997664319779818997585520416813922459267355934426368607473489745720599652869554865615372043424853098967308046422295118461130471747696561564617535249767562911218564247),
                      ScalarType(
                          0.0415284630901476974224119789640670178089779754858409900770369779521852810066505337033894639785000653543199247940076276702781088475205489401985605222658616647455668295744035872613926105162445460879372679080469473413669485040157849266788132495103028963867982810247165653013110017625307860661),
                      ScalarType(
                          0.0415284630901476974224119789640670178089779754858409900770369779521852810066505337033894639785000653543199247940076276702781088475205489401985605222658616647455668295744035872613926105162445460879372679080469473413669485040157849266788132495103028963867982810247165653013110017625307860661),
                      ScalarType(
                          0.038568756612587675244770150236385934864771705000518926510807400152266753249947479020171318147887407669699148297180522600539391466503697614682624242426880046497111854959730227822224610494054947231715167469242161155882926601159757012739020539776161367774706792966521335426028885109414537805),
                      ScalarType(0.038568756612587675244770150236385934864771705000518926510807400152266753249947479020171318147887407669699148297180522600539391466503697614682624242426880046497111854959730227822224610494054947231715167469242161155882926601159757012739020539776161367774706792966521335426028885109414537805),
                      ScalarType(
                          0.0354598356151461541607346110009757970969600004969844709128704508599711665304799705630640668049640238126696394380419907379503955293819633755652145958301737960247068800412033714746537177390275107383816819172073796541953142569288628557776771276366225834861950445500205918325393478764409996431),
                      ScalarType(
                          0.0354598356151461541607346110009757970969600004969844709128704508599711665304799705630640668049640238126696394380419907379503955293819633755652145958301737960247068800412033714746537177390275107383816819172073796541953142569288628557776771276366225834861950445500205918325393478764409996431),
                      ScalarType(
                          0.0322137282235780166481658273230039534485890588334252171583296054159113002451764634600621885258031843895035356680268477238846720276382240117467605812342957953994837188490052230941410296186300830228854450014025595966788892475461447355342233688977045020827005029856893142819770147092803439821),
                      ScalarType(
                          0.0322137282235780166481658273230039534485890588334252171583296054159113002451764634600621885258031843895035356680268477238846720276382240117467605812342957953994837188490052230941410296186300830228854450014025595966788892475461447355342233688977045020827005029856893142819770147092803439821),
                      ScalarType(
                          0.0288429935805351980299063731132324325178468655935374578357126230562653296642843390466277200547673991574846975798750985468255118305424015794455356767643380854134868810708427452633175969512666954713336776150048514778191254810795774602056446799780622170709599733556475059858754302007429798032),
                      ScalarType(0.0288429935805351980299063731132324325178468655935374578357126230562653296642843390466277200547673991574846975798750985468255118305424015794455356767643380854134868810708427452633175969512666954713336776150048514778191254810795774602056446799780622170709599733556475059858754302007429798032),
                      ScalarType(
                          0.0253606735700123904401948783854427234601612599757121373393963329520377577467275278746042485641112812210948127250697749464745053424003499073219081421087639806114725782423686151356176334891707357397125669841676191720237079416284620695420651119989843568903711718265753550654762411171703450081),
                      ScalarType(
                          0.0253606735700123904401948783854427234601612599757121373393963329520377577467275278746042485641112812210948127250697749464745053424003499073219081421087639806114725782423686151356176334891707357397125669841676191720237079416284620695420651119989843568903711718265753550654762411171703450081),
                      ScalarType(
                          0.021780243170124792981592069062690341227313462357934296044027139447670830221994978692528405062919036610750543988184459389787201683069180558744227305401230414887261661705663865566154900860877968946139457454588973130627030391289554278934416656126926195411019074492775663013159990535947112244),
                      ScalarType(
                          0.021780243170124792981592069062690341227313462357934296044027139447670830221994978692528405062919036610750543988184459389787201683069180558744227305401230414887261661705663865566154900860877968946139457454588973130627030391289554278934416656126926195411019074492775663013159990535947112244),
                      ScalarType(
                          0.0181155607134893903512599434223546198446673170497340354264529158733622897233659107514002021809730631088150939321765227490103352735558796697553684721170649011933661399026597449929061923375118129851679367723500846074579634471567200824783716259879992414056880302373215102412572472560511617743),
                      ScalarType(0.0181155607134893903512599434223546198446673170497340354264529158733622897233659107514002021809730631088150939321765227490103352735558796697553684721170649011933661399026597449929061923375118129851679367723500846074579634471567200824783716259879992414056880302373215102412572472560511617743),
                      ScalarType(
                          0.0143808227614855744193789089273243499370317861705878927721016221542517365633168875929040291288750820092046947340490223191159819387119533624327827984346761897882810460464837843710180794865913762173820888463912370242663735489505137991570616343466837217057560706590056964622010532542543453623),
                      ScalarType(
                          0.0143808227614855744193789089273243499370317861705878927721016221542517365633168875929040291288750820092046947340490223191159819387119533624327827984346761897882810460464837843710180794865913762173820888463912370242663735489505137991570616343466837217057560706590056964622010532542543453623),
                      ScalarType(
                          0.0105905483836509692635696814992410223394018190864591294563347171456491606290268573531131180287061868857866290798882540355464247606188273633281593909433230031790655254203200931965314220288613325252143665088580444388746098084157541099474412949255722933578429041377751704679271112676830648139),
                      ScalarType(
                          0.0105905483836509692635696814992410223394018190864591294563347171456491606290268573531131180287061868857866290798882540355464247606188273633281593909433230031790655254203200931965314220288613325252143665088580444388746098084157541099474412949255722933578429041377751704679271112676830648139),
                      ScalarType(
                          0.0067597991957454015027788781779850318018738324064668105528787058554029967944856787527566093874153215001888105419718171291279415096115053570914447616194407900935890266684583680811662741768053259969244873142935863704016269005056434462624167822195711509108470288942381864465704162582866654251),
                      ScalarType(
                          0.0067597991957454015027788781779850318018738324064668105528787058554029967944856787527566093874153215001888105419718171291279415096115053570914447616194407900935890266684583680811662741768053259969244873142935863704016269005056434462624167822195711509108470288942381864465704162582866654251),
                      ScalarType(
                          0.0029086225531551409584007243428554808066729964599463206185935272835507710401075371030889534746865396796712229961775201041637525208319912384405887138057352162245263117236613745907325298881366403327115219447579691089142464776280578769352296965930400516951643315492273864484850375720177732566),
                      ScalarType(
                          0.0029086225531551409584007243428554808066729964599463206185935272835507710401075371030889534746865396796712229961775201041637525208319912384405887138057352162245263117236613745907325298881366403327115219447579691089142464776280578769352296965930400516951643315492273864484850375720177732566)});
  }
}

/* This returns the algebraic signed distance to a paraboloid
 * returns < 0 number if a_pt is below the paraboloid
 * returns > 0 number if a_pt is above the paraboloid */
template <class ScalarType>
inline ScalarType signedDistance(
    const PtBase<ScalarType>& a_pt,
    const AlignedParaboloidBase<ScalarType>& a_paraboloid) {
  return a_paraboloid.a() * a_pt[0] * a_pt[0] +
         a_paraboloid.b() * a_pt[1] * a_pt[1] + a_pt[2];
}

template <class ScalarType>
inline ScalarType CstHalf(void) {
  return ScalarType(0.5);
}

template <class ScalarType>
inline ScalarType CstThird(void) {
  return ScalarType(0.333333333333333333333333333333);
}

template <class ScalarType>
inline ScalarType CstFourth(void) {
  return ScalarType(0.25);
}

template <class ScalarType>
inline ScalarType CstFifth(void) {
  return ScalarType(0.2);
}

template <class ScalarType>
inline ScalarType CstSixth(void) {
  return ScalarType(0.166666666666666666666666666667);
}

template <class ScalarType>
inline ScalarType CstSeventh(void) {
  return ScalarType(1) / ScalarType(7);
}

template <class ScalarType>
inline ScalarType CstEighth(void) {
  return ScalarType(0.125);
}
template <class ScalarType, UnsignedIndex_t OrderX, UnsignedIndex_t OrderY,
          UnsignedIndex_t OrderZ, UnsignedIndex_t ProjDir>
inline ScalarType MomentPlaneIntegrand(const PtBase<ScalarType>& a_position,
                                       const PtBase<ScalarType>& a_derivative,
                                       const NormalBase<ScalarType>& a_normal,
                                       const ScalarType& d,
                                       const ScalarType& w) {
  const ScalarType &x = a_position[0], &y = a_position[1], &z = a_position[2];
  const ScalarType &dy = a_derivative[1], &dz = a_derivative[2];
  const ScalarType &nx = a_normal[0], &ny = a_normal[1], &nz = a_normal[2];
  const ScalarType inv2 = CstHalf<ScalarType>();
  const ScalarType inv3 = CstThird<ScalarType>();
  const ScalarType inv4 = CstFourth<ScalarType>();
  const ScalarType inv6 = CstSixth<ScalarType>();
  const ScalarType inv8 = CstEighth<ScalarType>();
  // M0
  if constexpr (OrderX == 0 && OrderY == 0 && OrderZ == 0) {
    // Projection on YZ
    if constexpr (ProjDir == 0) {
      return w * dz * y * z;
    }
    // Projection on ZX
    else if constexpr (ProjDir == 1) {
      return w * dz * x * z;
    }
    // Projection on XY
    else if constexpr (ProjDir == 2) {
      return w * dy * (d * x - inv2 * nx * x * x - ny * x * y);
    }
  }
  // M1x
  else if constexpr (OrderX == 1 && OrderY == 0 && OrderZ == 0) {
    // Projection on YZ
    if constexpr (ProjDir == 0) {
      return w * dz * (d * y * z - inv2 * ny * y * y * z - nz * y * z * z) / nx;
    }
    // Projection on ZX
    else if constexpr (ProjDir == 1) {
      return w * dz * inv2 * x * x * z;
    }
    // Projection on XY
    else if constexpr (ProjDir == 2) {
      const auto x2 = x * x;
      return w * dy * (inv2 * d * x2 - inv3 * nx * x * x2 - inv2 * ny * x2 * y);
    }
  }
  // M1y
  else if constexpr (OrderX == 0 && OrderY == 1 && OrderZ == 0) {
    // Projection on YZ
    if constexpr (ProjDir == 0) {
      return w * dz * inv2 * y * y * z;
    }
    // Projection on ZX
    else if constexpr (ProjDir == 1) {
      return w * dz * (d * x * z - inv2 * nx * x * x * z - nz * x * z * z) / ny;
    }
    // Projection on XY
    else if constexpr (ProjDir == 2) {
      return w * dy * (d * x * y - inv2 * nx * x * x * y - ny * x * y * y);
    }
  }
  // M1z
  else if constexpr (OrderX == 0 && OrderY == 0 && OrderZ == 1) {
    // Projection on YZ
    if constexpr (ProjDir == 0) {
      return w * dz * inv2 * y * z * z;
    }
    // Projection on ZX
    else if constexpr (ProjDir == 1) {
      return w * dz * inv2 * x * z * z;
    }
    // Projection on XY
    else if constexpr (ProjDir == 2) {
      const auto x2 = x * x;
      return w * dy *
             (inv2 * d * d * x - inv2 * d * nx * x2 + inv6 * nx * nx * x * x2 -
              d * ny * x * y + inv2 * nx * ny * x2 * y +
              inv2 * ny * ny * x * y * y) /
             nz;
    }
  }
  // M2xx
  else if constexpr (OrderX == 2 && OrderY == 0 && OrderZ == 0) {
    // Projection on YZ
    if constexpr (ProjDir == 0) {
      return w * dz *
             (d * d * y * z - d * ny * y * y * z +
              inv3 * ny * ny * y * y * y * z -
              ScalarType(2) * d * nz * y * z * z + ny * nz * y * y * z * z +
              nz * nz * y * z * z * z) /
             (nx * nx);
    }
    // Projection on ZX
    else if constexpr (ProjDir == 1) {
      return w * dz * inv3 * x * x * x * z;
    }
    // Projection on XY
    else if constexpr (ProjDir == 2) {
      const auto x3 = x * x * x;
      return w * dy * (inv3 * d * x3 - inv4 * nx * x * x3 - inv3 * ny * x3 * y);
    }
  }
  // M2xy
  else if constexpr (OrderX == 1 && OrderY == 1 && OrderZ == 0) {
    // Projection on YZ
    if constexpr (ProjDir == 0) {
      return w * dz *
             (inv2 * d * y * y * z - inv3 * ny * y * y * y * z -
              inv2 * nz * y * y * z * z) /
             nx;
    }
    // Projection on ZX
    else if constexpr (ProjDir == 1) {
      return w * dz *
             (inv2 * d * x * x * z - inv3 * nx * x * x * x * z -
              inv2 * nz * x * x * z * z) /
             ny;
    }
    // Projection on XY
    else if constexpr (ProjDir == 2) {
      const auto x2 = x * x;
      return w * dy *
             (inv2 * d * x2 * y - inv3 * nx * x * x2 * y -
              inv2 * ny * x2 * y * y);
    }
  }
  // M2xz
  else if constexpr (OrderX == 1 && OrderY == 0 && OrderZ == 1) {
    // Projection on YZ
    if constexpr (ProjDir == 0) {
      return w * dz *
             (inv2 * d * y * z * z - inv4 * ny * y * y * z * z -
              inv2 * nz * y * z * z * z) /
             nx;
    }
    // Projection on ZX
    else if constexpr (ProjDir == 1) {
      return w * dz * inv4 * x * x * z * z;
    }
    // Projection on XY
    else if constexpr (ProjDir == 2) {
      const auto x2 = x * x;
      const auto x3 = x * x2;
      return w * dy *
             (inv4 * d * d * x2 - inv3 * d * nx * x3 + inv8 * nx * nx * x * x3 -
              inv2 * d * ny * x2 * y + inv3 * nx * ny * x3 * y +
              inv4 * ny * ny * x2 * y * y) /
             nz;
    }
  }
  // M2yy
  else if constexpr (OrderX == 0 && OrderY == 2 && OrderZ == 0) {
    // Projection on YZ
    if constexpr (ProjDir == 0) {
      return w * dz * inv3 * y * y * y * z;
    }
    // Projection on ZX
    else if constexpr (ProjDir == 1) {
      return w * dz *
             (d * d * x * z - d * nx * x * x * z +
              inv3 * nx * nx * x * x * x * z -
              ScalarType(2) * d * nz * x * z * z + nx * nz * x * x * z * z +
              nz * nz * x * z * z * z) /
             (ny * ny);
    }
    // Projection on XY
    else if constexpr (ProjDir == 2) {
      const auto y2 = y * y;
      return w * dy * (d * x * y2 - inv2 * nx * x * x * y2 - ny * x * y * y2);
    }
  }
  // M2yz
  else if constexpr (OrderX == 0 && OrderY == 1 && OrderZ == 1) {
    // Projection on YZ
    if constexpr (ProjDir == 0) {
      return w * dz * inv4 * y * y * z * z;
    }
    // Projection on ZX
    else if constexpr (ProjDir == 1) {
      return w * dz *
             (inv2 * d * x * z * z - inv4 * nx * x * x * z * z -
              inv2 * nz * x * z * z * z) /
             ny;
    }
    // Projection on XY
    else if constexpr (ProjDir == 2) {
      const auto x2 = x * x;
      const auto y2 = y * y;
      return w * dy *
             (inv2 * d * d * x * y - inv2 * d * nx * x2 * y +
              inv6 * nx * nx * x2 * x * y - d * ny * x * y2 +
              inv2 * nx * ny * x2 * y2 + inv2 * ny * ny * x * y * y2) /
             nz;
    }
  }
  // M2zz
  else if constexpr (OrderX == 0 && OrderY == 0 && OrderZ == 2) {
    // Projection on YZ
    if constexpr (ProjDir == 0) {
      return w * dz * inv3 * y * z * z * z;
    }
    // Projection on ZX
    else if constexpr (ProjDir == 1) {
      return w * dz * inv3 * x * z * z * z;
    }
    // Projection on XY
    else if constexpr (ProjDir == 2) {
      const auto d2 = d * d;
      const auto x2 = x * x;
      const auto x3 = x * x2;
      const auto y2 = y * y;
      const auto nx2 = nx * nx;
      const auto ny2 = ny * ny;
      return w * dy *
             (inv3 * d2 * d * x - inv2 * d2 * nx * x2 + inv3 * d * nx2 * x3 -
              inv2 * inv6 * nx * nx2 * x * x3 - d2 * ny * x * y +
              d * nx * ny * x2 * y - inv3 * nx2 * ny * x3 * y +
              d * ny2 * x * y2 - inv2 * nx * ny2 * x2 * y2 -
              inv3 * ny * ny2 * x * y * y2) /
             (nz * nz);
    }
  } else {
    return ScalarType(0);
  }
}

template <class ScalarType, UnsignedIndex_t OrderX, UnsignedIndex_t OrderY,
          UnsignedIndex_t OrderZ>
inline ScalarType MomentParaboloidIntegrand(
    const PtBase<ScalarType>& a_position,
    const PtBase<ScalarType>& a_derivative, const ScalarType& A,
    const ScalarType& B) {
  const ScalarType &x = a_position[0], &y = a_position[1],
                   &dy = a_derivative[1];
  const ScalarType inv2 = CstHalf<ScalarType>();
  const ScalarType inv3 = CstThird<ScalarType>();
  const ScalarType inv4 = CstFourth<ScalarType>();
  const ScalarType inv5 = CstFifth<ScalarType>();
  const ScalarType inv6 = CstSixth<ScalarType>();
  const ScalarType inv7 = CstSeventh<ScalarType>();

  // M0
  if constexpr (OrderX == 0 && OrderY == 0 && OrderZ == 0) {
    return -dy * (inv3 * A * x * x * x + B * x * y * y);
  }
  // M1x
  else if constexpr (OrderX == 1 && OrderY == 0 && OrderZ == 0) {
    const auto x2 = x * x;
    return -dy * (inv4 * A * x2 * x2 + inv2 * B * x2 * y * y);
  }
  // M1y
  else if constexpr (OrderX == 0 && OrderY == 1 && OrderZ == 0) {
    return -dy * (inv3 * A * x * x * x * y + B * x * y * y * y);
  }
  // M1z
  else if constexpr (OrderX == 0 && OrderY == 0 && OrderZ == 1) {
    const auto y2 = y * y;
    const auto x3 = x * x * x;
    return dy * (inv2 * inv5 * A * A * x3 * x * x + inv3 * A * B * x3 * y2 +
                 inv2 * B * B * x * y2 * y2);
  }
  // M2xx
  else if constexpr (OrderX == 2 && OrderY == 0 && OrderZ == 0) {
    const auto x3 = x * x * x;
    return -dy * (inv5 * A * x3 * x * x + inv3 * B * x3 * y * y);
  }
  // M2xy
  else if constexpr (OrderX == 1 && OrderY == 1 && OrderZ == 0) {
    const auto x2 = x * x;
    return -dy * (inv4 * A * x2 * x2 * y + inv2 * B * x2 * y * y * y);
  }
  // M2xz
  else if constexpr (OrderX == 1 && OrderY == 0 && OrderZ == 1) {
    const auto x2 = x * x;
    const auto y2 = y * y;
    const auto x4 = x2 * x2;
    return dy * (inv4 * inv3 * A * A * x4 * x2 * y + inv4 * A * B * x4 * y2 +
                 inv4 * B * B * x2 * y2 * y2);
  }
  // M2yy
  else if constexpr (OrderX == 0 && OrderY == 2 && OrderZ == 0) {
    const auto y2 = y * y;
    return -dy * (inv3 * A * x * x * x * y2 + B * x * y2 * y2);
  }
  // M2yz
  else if constexpr (OrderX == 0 && OrderY == 1 && OrderZ == 1) {
    const auto x3 = x * x * x;
    const auto y3 = y * y * y;
    return dy * (inv5 * inv2 * A * A * x3 * x * x * y + inv3 * A * B * x3 * y3 +
                 inv2 * B * B * x * y3 * y * y);
  }
  // M2zz
  else if constexpr (OrderX == 0 && OrderY == 0 && OrderZ == 2) {
    const auto x2 = x * x;
    const auto x3 = x * x2;
    const auto x5 = x2 * x3;
    const auto y2 = y * y;
    const auto y4 = y2 * y2;
    return -dy *
           (inv3 * inv7 * A * A * A * x5 * x2 + inv5 * A * A * B * x5 * y2 +
            inv3 * A * B * B * x3 * y4 + inv3 * B * B * B * x * y4 * y2);
  }
  return ScalarType(0);
}

template <UnsignedIndex_t ProjDir, class ReturnType, class ScalarType,
          class MomentFunctorType>
inline ReturnType MomentsIntegrandArc(const ScalarType a_t,
                                      const MomentFunctorType& a_functor) {
  using ReturnScalarType = typename ReturnType::value_type;
  const auto der_t = a_functor.der_t(a_t);
  const auto pos_t = a_functor.pos_t(a_t);
  const auto& normal = a_functor.face_normal();
  const auto& dist = a_functor.face_distance();
  const auto& weight = a_functor.norm_weight();
  const auto& a = a_functor.a();
  const auto& b = a_functor.b();
  if constexpr (std::is_same_v<ReturnType, VolumeBase<ReturnScalarType>>) {
    return ReturnType::fromScalarConstant(ReturnScalarType(
        MomentParaboloidIntegrand<ScalarType, 0, 0, 0>(pos_t, der_t, a, b) -
        MomentPlaneIntegrand<ScalarType, 0, 0, 0, ProjDir>(pos_t, der_t, normal,
                                                           dist, weight)));
  } else if constexpr (std::is_same_v<ReturnType,
                                      VolumeMomentsBase<ReturnScalarType>>) {
    auto integrand = ReturnType::fromScalarConstant(ReturnScalarType(0));
    integrand.volume() = ReturnScalarType(
        MomentParaboloidIntegrand<ScalarType, 0, 0, 0>(pos_t, der_t, a, b) -
        MomentPlaneIntegrand<ScalarType, 0, 0, 0, ProjDir>(pos_t, der_t, normal,
                                                           dist, weight));
    integrand.centroid()[0] = ReturnScalarType(
        MomentParaboloidIntegrand<ScalarType, 1, 0, 0>(pos_t, der_t, a, b) -
        MomentPlaneIntegrand<ScalarType, 1, 0, 0, ProjDir>(pos_t, der_t, normal,
                                                           dist, weight));
    integrand.centroid()[1] = ReturnScalarType(
        MomentParaboloidIntegrand<ScalarType, 0, 1, 0>(pos_t, der_t, a, b) -
        MomentPlaneIntegrand<ScalarType, 0, 1, 0, ProjDir>(pos_t, der_t, normal,
                                                           dist, weight));
    integrand.centroid()[2] = ReturnScalarType(
        MomentParaboloidIntegrand<ScalarType, 0, 0, 1>(pos_t, der_t, a, b) -
        MomentPlaneIntegrand<ScalarType, 0, 0, 1, ProjDir>(pos_t, der_t, normal,
                                                           dist, weight));
    return integrand;
  } else if constexpr (std::is_same_v<
                           ReturnType,
                           GeneralMomentsBase<2, 3, ReturnScalarType>>) {
    auto integrand = ReturnType::fromScalarConstant(ReturnScalarType(0));
    integrand[0] = ReturnScalarType(
        MomentParaboloidIntegrand<ScalarType, 0, 0, 0>(pos_t, der_t, a, b) -
        MomentPlaneIntegrand<ScalarType, 0, 0, 0, ProjDir>(pos_t, der_t, normal,
                                                           dist, weight));
    integrand[1] = ReturnScalarType(
        MomentParaboloidIntegrand<ScalarType, 1, 0, 0>(pos_t, der_t, a, b) -
        MomentPlaneIntegrand<ScalarType, 1, 0, 0, ProjDir>(pos_t, der_t, normal,
                                                           dist, weight));
    integrand[2] = ReturnScalarType(
        MomentParaboloidIntegrand<ScalarType, 0, 1, 0>(pos_t, der_t, a, b) -
        MomentPlaneIntegrand<ScalarType, 0, 1, 0, ProjDir>(pos_t, der_t, normal,
                                                           dist, weight));
    integrand[3] = ReturnScalarType(
        MomentParaboloidIntegrand<ScalarType, 0, 0, 1>(pos_t, der_t, a, b) -
        MomentPlaneIntegrand<ScalarType, 0, 0, 1, ProjDir>(pos_t, der_t, normal,
                                                           dist, weight));
    integrand[4] = ReturnScalarType(
        MomentParaboloidIntegrand<ScalarType, 2, 0, 0>(pos_t, der_t, a, b) -
        MomentPlaneIntegrand<ScalarType, 2, 0, 0, ProjDir>(pos_t, der_t, normal,
                                                           dist, weight));
    integrand[5] = ReturnScalarType(
        MomentParaboloidIntegrand<ScalarType, 1, 1, 0>(pos_t, der_t, a, b) -
        MomentPlaneIntegrand<ScalarType, 1, 1, 0, ProjDir>(pos_t, der_t, normal,
                                                           dist, weight));
    integrand[6] = ReturnScalarType(
        MomentParaboloidIntegrand<ScalarType, 1, 0, 1>(pos_t, der_t, a, b) -
        MomentPlaneIntegrand<ScalarType, 1, 0, 1, ProjDir>(pos_t, der_t, normal,
                                                           dist, weight));
    integrand[7] = ReturnScalarType(
        MomentParaboloidIntegrand<ScalarType, 0, 2, 0>(pos_t, der_t, a, b) -
        MomentPlaneIntegrand<ScalarType, 0, 2, 0, ProjDir>(pos_t, der_t, normal,
                                                           dist, weight));
    integrand[8] = ReturnScalarType(
        MomentParaboloidIntegrand<ScalarType, 0, 1, 1>(pos_t, der_t, a, b) -
        MomentPlaneIntegrand<ScalarType, 0, 1, 1, ProjDir>(pos_t, der_t, normal,
                                                           dist, weight));
    integrand[9] = ReturnScalarType(
        MomentParaboloidIntegrand<ScalarType, 0, 0, 2>(pos_t, der_t, a, b) -
        MomentPlaneIntegrand<ScalarType, 0, 0, 2, ProjDir>(pos_t, der_t, normal,
                                                           dist, weight));
    return integrand;
  } else {
    std::cout << "Paraboloid M>2 not available yet" << std::endl;
    return ReturnType::fromScalarConstant(ReturnScalarType(0));
  }
}

template <UnsignedIndex_t ProjDir, class ReturnType, class ScalarType,
          class MomentFunctorType>
inline ReturnType MomentsIntegrandLine(const ScalarType a_t,
                                       const MomentFunctorType& a_functor) {
  using ReturnScalarType = typename ReturnType::value_type;
  const auto der_t = a_functor.der_t(a_t);
  const auto pos_t = a_functor.pos_t(a_t);
  const auto& normal = a_functor.face_normal();
  const auto& dist = a_functor.face_distance();
  const auto& weight = a_functor.norm_weight();
  if constexpr (std::is_same_v<ReturnType, VolumeBase<ReturnScalarType>>) {
    return ReturnType::fromScalarConstant(
        ReturnScalarType(MomentPlaneIntegrand<ScalarType, 0, 0, 0, ProjDir>(
            pos_t, der_t, normal, dist, weight)));
  } else if constexpr (std::is_same_v<ReturnType,
                                      VolumeMomentsBase<ReturnScalarType>>) {
    auto integrand = ReturnType::fromScalarConstant(ReturnScalarType(0));
    integrand.volume() =
        ReturnScalarType(MomentPlaneIntegrand<ScalarType, 0, 0, 0, ProjDir>(
            pos_t, der_t, normal, dist, weight));
    integrand.centroid()[0] =
        ReturnScalarType(MomentPlaneIntegrand<ScalarType, 1, 0, 0, ProjDir>(
            pos_t, der_t, normal, dist, weight));
    integrand.centroid()[1] =
        ReturnScalarType(MomentPlaneIntegrand<ScalarType, 0, 1, 0, ProjDir>(
            pos_t, der_t, normal, dist, weight));
    integrand.centroid()[2] =
        ReturnScalarType(MomentPlaneIntegrand<ScalarType, 0, 0, 1, ProjDir>(
            pos_t, der_t, normal, dist, weight));
    return integrand;
  } else if constexpr (std::is_same_v<
                           ReturnType,
                           GeneralMomentsBase<2, 3, ReturnScalarType>>) {
    auto integrand = ReturnType::fromScalarConstant(ReturnScalarType(0));
    integrand[0] =
        ReturnScalarType(MomentPlaneIntegrand<ScalarType, 0, 0, 0, ProjDir>(
            pos_t, der_t, normal, dist, weight));
    integrand[1] =
        ReturnScalarType(MomentPlaneIntegrand<ScalarType, 1, 0, 0, ProjDir>(
            pos_t, der_t, normal, dist, weight));
    integrand[2] =
        ReturnScalarType(MomentPlaneIntegrand<ScalarType, 0, 1, 0, ProjDir>(
            pos_t, der_t, normal, dist, weight));
    integrand[3] =
        ReturnScalarType(MomentPlaneIntegrand<ScalarType, 0, 0, 1, ProjDir>(
            pos_t, der_t, normal, dist, weight));
    integrand[4] =
        ReturnScalarType(MomentPlaneIntegrand<ScalarType, 2, 0, 0, ProjDir>(
            pos_t, der_t, normal, dist, weight));
    integrand[5] =
        ReturnScalarType(MomentPlaneIntegrand<ScalarType, 1, 1, 0, ProjDir>(
            pos_t, der_t, normal, dist, weight));
    integrand[6] =
        ReturnScalarType(MomentPlaneIntegrand<ScalarType, 1, 0, 1, ProjDir>(
            pos_t, der_t, normal, dist, weight));
    integrand[7] =
        ReturnScalarType(MomentPlaneIntegrand<ScalarType, 0, 2, 0, ProjDir>(
            pos_t, der_t, normal, dist, weight));
    integrand[8] =
        ReturnScalarType(MomentPlaneIntegrand<ScalarType, 0, 1, 1, ProjDir>(
            pos_t, der_t, normal, dist, weight));
    integrand[9] =
        ReturnScalarType(MomentPlaneIntegrand<ScalarType, 0, 0, 2, ProjDir>(
            pos_t, der_t, normal, dist, weight));
    return integrand;
  } else {
    std::cout << "Paraboloid M>2 not available yet" << std::endl;
    return ReturnType::fromScalarConstant(ReturnScalarType(0));
  }
}

template <class ReturnType, class ScalarType, UnsignedIndex_t QuadRuleOrder>
class ParaboloidMomentLineIntegrator {
 public:
  using ReturnScalarType = typename ReturnType::value_type;
  using Pt = PtBase<ScalarType>;
  using Normal = NormalBase<ScalarType>;
  ParaboloidMomentLineIntegrator(const Pt& a_pt_start, const Pt& a_pt_end,
                                 const Normal& a_face_normal,
                                 const UnsignedIndex_t a_proj_dir)
      : lower_limit_m(ScalarType(0)),
        upper_limit_m(ScalarType(1)),
        start_m(a_pt_start),
        end_m(a_pt_end),
        face_normal_m(a_face_normal),
        face_distance_m(a_face_normal * a_pt_start) {
    switch (a_proj_dir) {
      case 0:
        integrand_m = MomentsIntegrandLine<0>;
        norm_weight_m = face_normal_m[2] / face_normal_m[0];
        break;
      case 1:
        integrand_m = MomentsIntegrandLine<1>;
        norm_weight_m = -face_normal_m[2] / face_normal_m[1];
        break;
      case 2:
        integrand_m = MomentsIntegrandLine<2>;
        norm_weight_m = ScalarType(1) / face_normal_m[2];
        break;
      default:
        UnsignedIndex_t max_component_index = 0;
        ScalarType max_component = fabs(face_normal_m[0]);
        for (UnsignedIndex_t d = 1; d < 3; ++d) {
          if (fabs(face_normal_m[d]) > max_component) {
            max_component_index = d;
            max_component = fabs(face_normal_m[d]);
          }
        }
        switch (max_component_index) {
          case 0:
            integrand_m = MomentsIntegrandLine<0>;
            norm_weight_m = face_normal_m[2] / face_normal_m[0];
            break;
          case 1:
            integrand_m = MomentsIntegrandLine<1>;
            norm_weight_m = -face_normal_m[2] / face_normal_m[1];
            break;
          default:
            integrand_m = MomentsIntegrandLine<2>;
            norm_weight_m = ScalarType(1) / face_normal_m[2];
        }
    }
  }
  const ReturnType operator()(const ScalarType a_t) const {
    return (*integrand_m)(a_t, (*this));
  }
  const ReturnType integrate(void) {
    const auto one = ScalarType(1), inv2 = ScalarType(0.5);
    const auto& abscissea = AbscissaeGauss<ScalarType, QuadRuleOrder>();
    const auto& weights = WeightsGauss<ScalarType, QuadRuleOrder>();
    auto moments = ReturnType::fromScalarConstant(ReturnScalarType(0));
    for (UnsignedIndex_t i = 0; i < QuadRuleOrder; ++i) {
      const auto t = lower_limit_m + (upper_limit_m - lower_limit_m) * inv2 *
                                         (one + abscissea[i]);
      moments += ReturnScalarType(inv2 * weights[i]) * (*this)(t);
    }
    return moments;
  }
  inline const Pt der_t(const ScalarType a_t) const {
    return Pt(end_m - start_m);
  }
  inline const Pt pos_t(const ScalarType a_t) const {
    return Pt(a_t * end_m + (ScalarType(1) - a_t) * start_m);
  }
  inline const Normal& face_normal(void) const { return face_normal_m; }
  inline const ScalarType& face_distance(void) const { return face_distance_m; }
  inline const ScalarType& norm_weight(void) const { return norm_weight_m; }

 private:
  const Pt start_m, end_m;
  const Normal face_normal_m;
  const ScalarType face_distance_m;
  ScalarType lower_limit_m, upper_limit_m;
  ScalarType norm_weight_m;
  ReturnType (*integrand_m)(const ScalarType,
                            const ParaboloidMomentLineIntegrator&);
};

template <class ReturnType, class ScalarType, UnsignedIndex_t QuadRuleOrder>
class ParaboloidMomentArcIntegrator {
 public:
  using ReturnScalarType = typename ReturnType::value_type;
  using AlignedParaboloid = AlignedParaboloidBase<ScalarType>;
  using RationalBezierArc = RationalBezierArcBase<ScalarType>;
  using Pt = PtBase<ScalarType>;
  using Normal = NormalBase<ScalarType>;
  ParaboloidMomentArcIntegrator(const AlignedParaboloid& a_paraboloid,
                                const RationalBezierArc& a_arc,
                                const Normal& a_face_normal,
                                const UnsignedIndex_t a_proj_dir)
      : lower_limit_m(ScalarType(0)),
        upper_limit_m(ScalarType(1)),
        arc_m(a_arc),
        face_normal_m(a_face_normal),
        a_m(a_paraboloid.a()),
        b_m(a_paraboloid.b()),
        face_distance_m(a_face_normal * a_arc.start_point()) {
    switch (a_proj_dir) {
      case 0:
        integrand_m = MomentsIntegrandArc<0>;
        norm_weight_m = face_normal_m[2] / face_normal_m[0];
        break;
      case 1:
        integrand_m = MomentsIntegrandArc<1>;
        norm_weight_m = -face_normal_m[2] / face_normal_m[1];
        break;
      case 2:
        integrand_m = MomentsIntegrandArc<2>;
        norm_weight_m = ScalarType(1) / face_normal_m[2];
        break;
      default:
        UnsignedIndex_t max_component_index = 0;
        ScalarType max_component = fabs(face_normal_m[0]);
        for (UnsignedIndex_t d = 1; d < 3; ++d) {
          if (fabs(face_normal_m[d]) > max_component) {
            max_component_index = d;
            max_component = fabs(face_normal_m[d]);
          }
        }
        switch (max_component_index) {
          case 0:
            integrand_m = MomentsIntegrandArc<0>;
            norm_weight_m = face_normal_m[2] / face_normal_m[0];
            break;
          case 1:
            integrand_m = MomentsIntegrandArc<1>;
            norm_weight_m = -face_normal_m[2] / face_normal_m[1];
            break;
          default:
            integrand_m = MomentsIntegrandArc<2>;
            norm_weight_m = ScalarType(1) / face_normal_m[2];
        }
    }
  }
  const ReturnType operator()(const ScalarType a_t) const {
    return (*integrand_m)(a_t, (*this));
  }
  const ReturnType integrate(void) {
    const auto one = ScalarType(1), inv2 = ScalarType(0.5);
    const auto& abscissea = AbscissaeGauss<ScalarType, QuadRuleOrder>();
    const auto& weights = WeightsGauss<ScalarType, QuadRuleOrder>();
    auto moments = ReturnType::fromScalarConstant(ReturnScalarType(0));
    for (UnsignedIndex_t i = 0; i < QuadRuleOrder; ++i) {
      const auto t = lower_limit_m + (upper_limit_m - lower_limit_m) * inv2 *
                                         (one + abscissea[i]);
      moments += ReturnScalarType(inv2 * weights[i]) * (*this)(t);
    }
    return moments;
  }
  inline const Pt der_t(const ScalarType a_t) const {
    return arc_m.derivative(a_t);
  }
  inline const Pt pos_t(const ScalarType a_t) const { return arc_m.point(a_t); }
  inline const Normal& face_normal(void) const { return face_normal_m; }
  inline const ScalarType& face_distance(void) const { return face_distance_m; }
  inline const ScalarType& norm_weight(void) const { return norm_weight_m; }
  inline const ScalarType& a(void) const { return a_m; }
  inline const ScalarType& b(void) const { return b_m; }

 private:
  const RationalBezierArc arc_m;
  const Normal face_normal_m;
  const ScalarType face_distance_m, a_m, b_m;
  ScalarType norm_weight_m;
  ScalarType lower_limit_m, upper_limit_m;
  ReturnType (*integrand_m)(const ScalarType,
                            const ParaboloidMomentArcIntegrator&);
};

/******************************************************************************/
/*********************** First moment contribution
 * ****************************/
/******************************************************************************/
/* This compute the first contribution to the moments (arising from the
 * integration of the face plane primitives on the poligonized clipped faces)
 */
template <class ReturnType, class ScalarType>
ReturnType computeType1Contribution(const PtBase<ScalarType>& a_ref_pt,
                                    const PtBase<ScalarType>& a_pt_0,
                                    const PtBase<ScalarType>& a_pt_1,
                                    bool* a_skip_first, bool a_is_arc,
                                    const NormalBase<ScalarType>& a_face_normal,
                                    const UnsignedIndex_t a_proj_dir) {
  using ReturnScalarType = typename ReturnType::value_type;
  if constexpr (std::is_same_v<ReturnType, VolumeBase<ReturnScalarType>>) {
    if (*a_skip_first) {
      *a_skip_first = false;
      return ReturnType::fromScalarConstant(ReturnScalarType(0));
    } else {
      return ReturnType::fromScalarConstant(ReturnScalarType(
          (a_ref_pt[2] + a_pt_0[2] + a_pt_1[2]) / ScalarType(6.0) *
          ((a_pt_0[0] - a_ref_pt[0]) * (a_pt_1[1] - a_ref_pt[1]) -
           (a_pt_1[0] - a_ref_pt[0]) * (a_pt_0[1] - a_ref_pt[1]))));
    }
  } else if constexpr (std::is_same_v<ReturnType,
                                      VolumeMomentsBase<ReturnScalarType>>) {
    if (*a_skip_first) {
      *a_skip_first = false;
      return ReturnType::fromScalarConstant(ReturnScalarType(0));
    } else {
      /* Defining constants and types */
      const ScalarType ZERO = ScalarType(0);
      const ScalarType ONE = ScalarType(1);
      const ScalarType TWO = ScalarType(2);
      const ScalarType THREE = ScalarType(3);
      const ScalarType ONETWELVTH = ONE / ScalarType(12);

      /* Function */
      auto moments = ReturnType::fromScalarConstant(ReturnScalarType(ZERO));
      const ScalarType triangle_area =
          ((a_pt_0[0] - a_ref_pt[0]) * (a_pt_1[1] - a_ref_pt[1]) -
           (a_pt_1[0] - a_ref_pt[0]) * (a_pt_0[1] - a_ref_pt[1])) /
          TWO;
      moments.volume() = ReturnScalarType(
          triangle_area * (a_ref_pt[2] + a_pt_0[2] + a_pt_1[2]) / THREE);
      moments.centroid()[0] = ReturnScalarType(
          triangle_area *
          (a_pt_0[0] * (TWO * a_pt_0[2] + a_pt_1[2] + a_ref_pt[2]) +
           a_pt_1[0] * (a_pt_0[2] + TWO * a_pt_1[2] + a_ref_pt[2]) +
           a_ref_pt[0] * (a_pt_0[2] + a_pt_1[2] + TWO * a_ref_pt[2])) *
          ONETWELVTH);
      moments.centroid()[1] = ReturnScalarType(
          triangle_area *
          (a_pt_0[1] * (TWO * a_pt_0[2] + a_pt_1[2] + a_ref_pt[2]) +
           a_pt_1[1] * (a_pt_0[2] + TWO * a_pt_1[2] + a_ref_pt[2]) +
           a_ref_pt[1] * (a_pt_0[2] + a_pt_1[2] + TWO * a_ref_pt[2])) *
          ONETWELVTH);
      moments.centroid()[2] = ReturnScalarType(
          triangle_area *
          (a_pt_0[2] * a_pt_0[2] + a_pt_1[2] * a_pt_1[2] +
           a_ref_pt[2] * a_ref_pt[2] + a_pt_1[2] * a_ref_pt[2] +
           a_pt_0[2] * a_pt_1[2] + a_pt_0[2] * a_ref_pt[2]) *
          ONETWELVTH);
      return moments;
    }
  } else if constexpr (std::is_same_v<
                           ReturnType,
                           GeneralMomentsBase<2, 3, ReturnScalarType>>) {
    if (!a_is_arc) {
      ParaboloidMomentLineIntegrator<ReturnType, ScalarType, 5> integrator(
          a_pt_0, a_pt_1, a_face_normal, a_proj_dir);
      return integrator.integrate();
    } else {
      return ReturnType::fromScalarConstant(ReturnScalarType(0));
    }
  } else {
    std::cout << "Type 1 for moments with order > 2 not yet implemented"
              << std::endl;
    return ReturnType::fromScalarConstant(ReturnScalarType(0));
  }
}

template <class ReturnType, class ScalarType>
ReturnType computeType2Contribution(
    const AlignedParaboloidBase<ScalarType>& a_aligned_paraboloid,
    const PtBase<ScalarType>& a_pt_0, const PtBase<ScalarType>& a_pt_1) {
  using ReturnScalarType = typename ReturnType::value_type;
  if constexpr (std::is_same_v<ReturnType, VolumeBase<ReturnScalarType>>) {
    const ScalarType ONETWELVTH = ScalarType(1) / ScalarType(12);
    return ReturnType::fromScalarConstant(ReturnScalarType(
        ONETWELVTH * (a_pt_0[0] * a_pt_1[1] - a_pt_1[0] * a_pt_0[1]) *
        (-a_pt_0[2] - a_pt_1[2] +
         a_aligned_paraboloid.a() * a_pt_0[0] * a_pt_1[0] +
         a_aligned_paraboloid.b() * a_pt_0[1] * a_pt_1[1])));
  } else if constexpr (std::is_same_v<ReturnType,
                                      VolumeMomentsBase<ReturnScalarType>>) {
    /* Defining constants and types */
    const ScalarType ZERO = ScalarType(0);
    const ScalarType ONE = ScalarType(1);
    const ScalarType TWO = ScalarType(2);
    const ScalarType THREE = ScalarType(3);
    const ScalarType ONETWELVTH = ONE / ScalarType(12);
    const ScalarType ONE60TH = ONE / ScalarType(60);
    const ScalarType ONE180TH = ONE / ScalarType(180);

    /* Function */
    auto moments = ReturnType::fromScalarConstant(ReturnScalarType(ZERO));
    moments.volume() = ReturnScalarType(
        (a_pt_0[0] * a_pt_1[1] - a_pt_1[0] * a_pt_0[1]) * ONETWELVTH *
        (-a_pt_0[2] - a_pt_1[2] +
         a_aligned_paraboloid.a() * a_pt_0[0] * a_pt_1[0] +
         a_aligned_paraboloid.b() * a_pt_0[1] * a_pt_1[1]));
    moments.centroid()[0] = ReturnScalarType(
        (a_pt_1[0] * a_pt_0[1] - a_pt_0[0] * a_pt_1[1]) *
        (TWO * a_aligned_paraboloid.b() * (a_pt_0[1] - a_pt_1[1]) *
             (a_pt_1[0] * a_pt_0[1] - a_pt_0[0] * a_pt_1[1]) +
         THREE * (a_pt_0[0] + a_pt_1[0]) * (a_pt_0[2] + a_pt_1[2])) *
        ONE60TH);
    moments.centroid()[1] = ReturnScalarType(
        (a_pt_1[0] * a_pt_0[1] - a_pt_0[0] * a_pt_1[1]) *
        (TWO * a_aligned_paraboloid.a() * (a_pt_0[0] - a_pt_1[0]) *
             (a_pt_1[1] * a_pt_0[0] - a_pt_0[1] * a_pt_1[0]) +
         THREE * (a_pt_0[1] + a_pt_1[1]) * (a_pt_0[2] + a_pt_1[2])) *
        ONE60TH);
    moments.centroid()[2] = ReturnScalarType(
        ((a_pt_0[0] * a_pt_1[1] - a_pt_1[0] * a_pt_0[1]) *
         (TWO * a_aligned_paraboloid.a() * a_aligned_paraboloid.b() *
              ((a_pt_1[0] * a_pt_0[1] - a_pt_0[0] * a_pt_1[1]) *
               (a_pt_1[0] * a_pt_0[1] - a_pt_0[0] * a_pt_1[1])) +
          THREE * a_aligned_paraboloid.a() * a_pt_0[0] * a_pt_1[0] *
              (a_pt_0[2] + a_pt_1[2]) +
          THREE * a_aligned_paraboloid.b() * a_pt_0[1] * a_pt_1[1] *
              (a_pt_0[2] + a_pt_1[2]) -
          THREE * (a_pt_0[2] * a_pt_0[2] + a_pt_0[2] * a_pt_1[2] +
                   a_pt_1[2] * a_pt_1[2]))) *
        ONE180TH);
    return moments;
  } else if constexpr (std::is_same_v<
                           ReturnType,
                           GeneralMomentsBase<2, 3, ReturnScalarType>>) {
    return ReturnType::fromScalarConstant(ReturnScalarType(0));
  } else {
    std::cout << "Type 2 for moments with order > 2 not yet implemented"
              << std::endl;
    return ReturnType::fromScalarConstant(ReturnScalarType(0));
  }
}

template <class ContainerType, class ScalarType>
inline std::array<ContainerType, 3> coeffsV3SeriesOne(
    const ContainerType& a_weight) {
  std::array<ContainerType, 3> coeffs;
  coeffs.fill(ContainerType(ScalarType(0)));
  ContainerType x(ScalarType(1));
  UnsignedIndex_t i = 0;
  ScalarType max_diff;
  while (i <= 40) {
    max_diff = ScalarType(0);
    for (UnsignedIndex_t j = 0; j < 3; ++j) {
      ContainerType add_to_coeff = ScalarType(v3Series[i][j]) * x;
      coeffs[j] += add_to_coeff;
      max_diff = maximum(max_diff, fabs(add_to_coeff));
    }
    if (max_diff < ScalarType(DBL_EPSILON)) {
      break;
    }
    x *= a_weight - ContainerType(ScalarType(1));
    i++;
  }
  return coeffs;
}

template <class ContainerType, class ScalarType>
inline std::array<ContainerType, 12> coeffsV3andC3SeriesOne(
    const ContainerType& a_weight) {
  std::array<ContainerType, 12> coeffs;
  coeffs.fill(ContainerType(ScalarType(0)));
  ContainerType x(ScalarType(1));
  UnsignedIndex_t i = 0;
  ScalarType max_diff;
  while (i <= 40) {
    max_diff = ScalarType(0);
    for (UnsignedIndex_t j = 0; j < 3; ++j) {
      ContainerType add_to_coeff = ScalarType(v3Series[i][j]) * x;
      coeffs[j] += add_to_coeff;
      max_diff = maximum(max_diff, fabs(add_to_coeff));
    }
    if (max_diff < ScalarType(DBL_EPSILON)) {
      break;
    }
    x *= a_weight - ContainerType(ScalarType(1));
    i++;
  }
  i = 0;
  x = ContainerType(ScalarType(1));
  while (i <= 40) {
    max_diff = ScalarType(0);
    for (UnsignedIndex_t j = 0; j < 4; ++j) {
      ContainerType add_to_coeff = ScalarType(cx3Series[i][j]) * x;
      coeffs[3 + j] += add_to_coeff;
      max_diff = maximum(max_diff, fabs(add_to_coeff));
    }
    for (UnsignedIndex_t j = 0; j < 5; ++j) {
      ContainerType add_to_coeff = ScalarType(cz3Series[i][j]) * x;
      coeffs[7 + j] += add_to_coeff;
      max_diff = maximum(max_diff, fabs(add_to_coeff));
    }
    if (max_diff < ScalarType(DBL_EPSILON)) {
      break;
    }
    x *= a_weight - ContainerType(ScalarType(1));
    i++;
  }

  return coeffs;
}

template <class ContainerType, class ScalarType>
inline std::array<ContainerType, 3> coeffsV3Exact(
    const ContainerType& a_weight) {
  /* Defining constants and types */
  const ScalarType ONE = ScalarType(1);
  const ScalarType TWO = ScalarType(2);
  const ScalarType THREE = ScalarType(3);
  const ScalarType FOUR = ScalarType(4);
  const ScalarType SIX = ScalarType(6);

  /* Function */
  const auto w2 = a_weight * a_weight;
  const auto w3 = w2 * a_weight;
  const auto w4 = w2 * w2;
  const auto w5 = w2 * w3;
  const auto w6 = w3 * w3;
  const auto L = ContainerType(ONE) / ((a_weight - ContainerType(ONE)) *
                                       (a_weight + ContainerType(ONE)));
  const auto L3 = L * L * L;
  const auto S = (a_weight < ContainerType(ONE))
                     ? sqrt(ContainerType(ONE) - a_weight * a_weight)
                     : sqrt(a_weight * a_weight - ContainerType(ONE));
  const auto T = (a_weight < ContainerType(ONE))
                     ? atan((ContainerType(ONE) - a_weight) / S) / S
                     : atanh((a_weight - ContainerType(ONE)) / S) / S;
  return std::array<ContainerType, 3>(
      {(TWO * w6 - THREE * w4 + ScalarType(31) * w2 -
        (ScalarType(42) * w3 + ScalarType(18) * a_weight) * T) *
           L3 / ScalarType(12),
       (TWO * w6 - ScalarType(9) * w4 - ScalarType(8) * w2 +
        ScalarType(30) * w3 * T) *
           L3 / THREE,
       (ScalarType(11) * w4 + FOUR * w2 -
        (ScalarType(12) * w5 + ScalarType(18) * w3) * T) *
           L3 / SIX});
}

template <class ContainerType, class ScalarType>
inline std::array<ContainerType, 12> coeffsV3andC3Exact(
    const ContainerType& a_weight) {
  /* Defining constants and types */
  const ScalarType ONE = ScalarType(1);
  const ScalarType TWO = ScalarType(2);
  const ScalarType THREE = ScalarType(3);
  const ScalarType FOUR = ScalarType(4);
  const ScalarType FIVE = ScalarType(5);
  const ScalarType SIX = ScalarType(6);

  /* Function */
  const auto w2 = a_weight * a_weight;
  const auto w3 = w2 * a_weight;
  const auto w4 = w2 * w2;
  const auto w5 = w2 * w3;
  const auto w6 = w3 * w3;
  const auto w7 = w4 * w3;
  const auto w8 = w4 * w4;
  const auto w9 = w4 * w5;
  const auto w10 = w5 * w5;
  const auto L = ContainerType(ONE) / ((a_weight - ContainerType(ONE)) *
                                       (a_weight + ContainerType(ONE)));
  const auto L3 = L * L * L;
  const auto L4 = L3 * L;
  const auto L5 = L4 * L;
  const auto S = (a_weight < ContainerType(ONE))
                     ? sqrt(ContainerType(ONE) - a_weight * a_weight)
                     : sqrt(a_weight * a_weight - ContainerType(ONE));
  const auto T = (a_weight < ContainerType(ONE))
                     ? atan((ContainerType(ONE) - a_weight) / S) / S
                     : atanh((a_weight - ContainerType(ONE)) / S) / S;
  return std::array<ContainerType, 12>(
      {L3 *
           (TWO * w6 - THREE * w4 + ScalarType(31) * w2 -
            (ScalarType(42) * w3 + ScalarType(18) * a_weight) * T) /
           ScalarType(12),
       L3 *
           (TWO * w6 - ScalarType(9) * w4 - ScalarType(8) * w2 +
            ScalarType(30) * w3 * T) /
           THREE,
       L3 *
           (ScalarType(11) * w4 + FOUR * w2 -
            (ScalarType(12) * w5 + ScalarType(18) * w3) * T) /
           SIX,
       L4 * ((-T * a_weight) / ScalarType(32) +
             (ScalarType(93) * (w2)) / ScalarType(2240) -
             (ScalarType(163) * (w4)) / ScalarType(3360) +
             (FIVE * (w6)) / ScalarType(168) - (w8) / ScalarType(140)),
       L4 * ((w2) / ScalarType(70) + (-T * (w3)) / ScalarType(16) +
             (ScalarType(29) * (w4)) / ScalarType(1120) -
             (ScalarType(19) * (w6)) / ScalarType(1680) +
             (w8) / ScalarType(420)),
       -L4 *
           ((w2) / ScalarType(210) - (w4) / ScalarType(21) -
            (-T * (w5)) / ScalarType(8) -
            (ScalarType(13) * (w6)) / ScalarType(560) + (w8) / ScalarType(280)),
       L4 * ((w2) / ScalarType(35) - (ScalarType(16) * (w4)) / ScalarType(105) +
             (ScalarType(58) * (w6)) / ScalarType(105) - T * (w7) +
             (w8) / ScalarType(14)),
       L5 * ((-T * a_weight) / ScalarType(128) +
             (ScalarType(193) * (w2)) / ScalarType(16128) -
             (ScalarType(149) * (w4)) / ScalarType(8064) +
             (ScalarType(19) * (w6)) / ScalarType(1120) -
             (ScalarType(41) * (w8)) / ScalarType(5040) +
             (w10) / ScalarType(630)),
       L5 * ((FOUR * (w2)) / ScalarType(945) + (-T * (w3)) / ScalarType(48) +
             (ScalarType(65) * (w4)) / ScalarType(6048) -
             (w6) / ScalarType(144) +
             (ScalarType(11) * (w8)) / ScalarType(3780) -
             (w10) / ScalarType(1890)),
       -L5 * ((w2) / ScalarType(1890) -
              (ScalarType(13) * (w4)) / ScalarType(1890) -
              (-T * (w5)) / ScalarType(48) -
              (ScalarType(11) * (w6)) / ScalarType(2016) +
              (ScalarType(5) * (w8)) / ScalarType(3024) -
              (w10) / ScalarType(3780)),
       L5 * ((w2) / ScalarType(315) - (w4) / ScalarType(45) +
             (ScalarType(4) * (w6)) / ScalarType(35) +
             (-T * (w7)) / ScalarType(4) +
             (ScalarType(17) * (w8)) / ScalarType(504) -
             (w10) / ScalarType(252)),
       -L5 *
           ((w2) / ScalarType(63) - (ScalarType(29) * (w4)) / ScalarType(315) +
            (ScalarType(26) * (w6)) / ScalarType(105) -
            (ScalarType(194) * (w8)) / ScalarType(315) + T * (w9) -
            (w10) / ScalarType(18))});
}

template <class ReturnType, class ScalarType>
ReturnType computeType3Contribution(
    const AlignedParaboloidBase<ScalarType>& a_paraboloid,
    const RationalBezierArcBase<ScalarType>& a_arc,
    const NormalBase<ScalarType>& a_face_normal) {
  using ReturnScalarType = typename ReturnType::value_type;
  if constexpr (std::is_same_v<ReturnType, VolumeBase<ReturnScalarType>>) {
    /* Defining constants and types */
    const ScalarType ZERO = ScalarType(0);
    const ScalarType ONE = ScalarType(1);
    const ScalarType TWO = ScalarType(2);
    const ScalarType THREE = ScalarType(3);
    const ScalarType FOUR = ScalarType(4);
    const ScalarType FIVE = ScalarType(5);
    const ScalarType SIX = ScalarType(6);
    const ScalarType HALF = ONE / TWO;
    const ScalarType QUARTER = ONE / FOUR;

    const auto& pt_0 = a_arc.start_point();
    const auto& cp = a_arc.control_point();
    const auto& pt_1 = a_arc.end_point();
    const auto& weight = a_arc.weight();
    const ScalarType area_proj_triangle =
        HALF * (pt_0[0] * (pt_1[1] - cp[1]) + pt_1[0] * (cp[1] - pt_0[1]) +
                cp[0] * (pt_0[1] - pt_1[1]));
    assert(weight >= ZERO);
    std::array<ScalarType, 3> coeffs;
    if (weight < ScalarType(0.35))  // We use the exact expressions
      coeffs = coeffsV3Exact<ScalarType, ScalarType>(weight);
    else if (weight <
             ScalarType(1.7))  // We use the 40th order Taylor series (w -> 1)
      coeffs = coeffsV3SeriesOne<ScalarType, ScalarType>(weight);
    else if (weight <
             ScalarType(1.0e9))  // We use the series expansion (w -> infty)
      coeffs = coeffsV3Exact<ScalarType, ScalarType>(weight);
    else  // This is within EPSILON of the actual value
      coeffs = std::array<ScalarType, 3>({ONE / SIX, TWO / THREE, ZERO});

    return ReturnType::fromScalarConstant(ReturnScalarType(
        area_proj_triangle *
        (coeffs[0] *
             signedDistance<ScalarType>(HALF * (pt_0 + pt_1), a_paraboloid) +
         coeffs[1] * signedDistance<ScalarType>(
                         QUARTER * (pt_0 + pt_1) + HALF * cp, a_paraboloid) +
         coeffs[2] * signedDistance<ScalarType>(cp, a_paraboloid))));
  } else if constexpr (std::is_same_v<ReturnType,
                                      VolumeMomentsBase<ReturnScalarType>>) {
    /* Defining constants and types */
    const ScalarType ZERO = ScalarType(0);
    const ScalarType ONE = ScalarType(1);
    const ScalarType TWO = ScalarType(2);
    const ScalarType THREE = ScalarType(3);
    const ScalarType FOUR = ScalarType(4);
    const ScalarType FIVE = ScalarType(5);
    const ScalarType SIX = ScalarType(6);
    const ScalarType HALF = ONE / TWO;
    const ScalarType QUARTER = ONE / FOUR;

    /* Function */
    auto moments = ReturnType::fromScalarConstant(ReturnScalarType(ZERO));
    const auto& pt_0 = a_arc.start_point();
    const auto& cp = a_arc.control_point();
    const auto& pt_1 = a_arc.end_point();
    const auto weight = a_arc.weight();
    const auto A = a_paraboloid.a(), B = a_paraboloid.b();
    const auto X0 = pt_0[0], X1 = cp[0], X2 = pt_1[0];
    const auto Y0 = pt_0[1], Y1 = cp[1], Y2 = pt_1[1];
    const auto Z0 = pt_0[2], Z1p = cp[2], Z2 = pt_1[2];
    const ScalarType Z1P = -A * X1 * X1 - B * Y1 * Y1;
    const ScalarType AA = A * A, BB = B * B, AB = A * B;
    const ScalarType X00 = X0 * X0, X11 = X1 * X1, X22 = X2 * X2;
    const ScalarType X000 = X00 * X0, X111 = X11 * X1, X222 = X22 * X2;
    const ScalarType X0000 = X00 * X00, X1111 = X11 * X11, X2222 = X22 * X22;
    const ScalarType Y00 = Y0 * Y0, Y11 = Y1 * Y1, Y22 = Y2 * Y2;
    const ScalarType Y000 = Y00 * Y0, Y111 = Y11 * Y1, Y222 = Y22 * Y2;
    const ScalarType Y0000 = Y00 * Y00, Y1111 = Y11 * Y11, Y2222 = Y22 * Y22;
    const ScalarType Z00 = Z0 * Z0, Z22 = Z2 * Z2;
    const ScalarType Z1p1p = Z1p * Z1p, Z1P1P = Z1P * Z1P;
    const ScalarType X02 = X0 * X2, X12 = X1 * X2, X01 = X0 * X1;
    const ScalarType Y02 = Y0 * Y2, Y12 = Y1 * Y2, Y01 = Y0 * Y1;
    const ScalarType Z02 = Z0 * Z2, Z01p = Z0 * Z1p, Z01P = Z0 * Z1P;
    const ScalarType Z1p1P = Z1p * Z1P, Z1p2 = Z1p * Z2, Z1P2 = Z1P * Z2;
    const ScalarType X0Z0 = X0 * Z0, X0Z1p = X0 * Z1p, X0Z1P = X0 * Z1P,
                     X0Z2 = X0 * Z2;
    const ScalarType X1Z0 = X1 * Z0, X1Z1p = X1 * Z1p, X1Z1P = X1 * Z1P,
                     X1Z2 = X1 * Z2;
    const ScalarType X2Z0 = X2 * Z0, X2Z1p = X2 * Z1p, X2Z1P = X2 * Z1P,
                     X2Z2 = X2 * Z2;
    const ScalarType Y0Z0 = Y0 * Z0, Y0Z1p = Y0 * Z1p, Y0Z1P = Y0 * Z1P,
                     Y0Z2 = Y0 * Z2;
    const ScalarType Y1Z0 = Y1 * Z0, Y1Z1p = Y1 * Z1p, Y1Z1P = Y1 * Z1P,
                     Y1Z2 = Y1 * Z2;
    const ScalarType Y2Z0 = Y2 * Z0, Y2Z1p = Y2 * Z1p, Y2Z1P = Y2 * Z1P,
                     Y2Z2 = Y2 * Z2;
    const ScalarType area_proj_triangle =
        HALF * (X0 * (Y2 - Y1) + X2 * (Y1 - Y0) + X1 * (Y0 - Y2));
    assert(weight >= ZERO);
    // Compute coefficients (functions of the weight)
    std::array<ScalarType, 12> coeffs;
    if (weight < ScalarType(0.35))  // We use the exact expressions
    {
      coeffs = coeffsV3andC3Exact<ScalarType, ScalarType>(weight);
    } else if (weight <
               ScalarType(1.7))  // We use the 40th order Taylor series (w -> 1)
    {
      coeffs = coeffsV3andC3SeriesOne<ScalarType, ScalarType>(weight);
    } else if (weight < ScalarType(1.0e9))  // We use the exact expressions
    {
      coeffs = coeffsV3andC3Exact<ScalarType, ScalarType>(weight);
    }
    // else if (weight < 1.0e9)  // We use the series expansion (w -> infty)
    //   coeffs = coeffsV3andC3SeriesInfinity(weight);
    else  // This is within EPSILON of the actual value
    {
      coeffs = std::array<ScalarType, 12>(
          {ScalarType(ONE / SIX), ScalarType(TWO / THREE), ScalarType(ZERO),
           ScalarType(-ONE / ScalarType(140)),
           ScalarType(ONE / ScalarType(420)),
           ScalarType(-ONE / ScalarType(280)), ScalarType(ONE / ScalarType(14)),
           ScalarType(ONE / ScalarType(630)),
           ScalarType(-ONE / ScalarType(1890)),
           ScalarType(ONE / ScalarType(3780)),
           ScalarType(-ONE / ScalarType(252)),
           ScalarType(ONE / ScalarType(18))});
    }
    auto m0_basis = std::array<ScalarType, 3>(
        {signedDistance<ScalarType>(HALF * (pt_0 + pt_1), a_paraboloid),
         signedDistance<ScalarType>(QUARTER * (pt_0 + pt_1) + HALF * cp,
                                    a_paraboloid),
         signedDistance<ScalarType>(cp, a_paraboloid)});
    auto m1x_basis = std::array<ScalarType, 4>(
        {-SIX * (X0Z0 - X0Z2 - X2Z0 + X2Z2 - TWO * B * X2 * Y00 +
                 TWO * B * X0 * Y02 + TWO * B * X2 * Y02 - TWO * B * X0 * Y22),
         TWO * (FIVE * X0Z0 + ScalarType(10) * X0Z1p + SIX * X0Z1P +
                ScalarType(7) * X0Z2 + ScalarType(30) * A * X02 * X1 -
                ScalarType(11) * X1Z0 - FOUR * X1Z1p - ScalarType(11) * X1Z2 +
                ScalarType(7) * X2Z0 + ScalarType(10) * X2Z1p + SIX * X2Z1P +
                FIVE * X2Z2 - ScalarType(14) * B * X1 * Y00 +
                FOUR * B * X2 * Y00 + ScalarType(14) * B * X0 * Y01 -
                FOUR * B * X1 * Y01 + ScalarType(10) * B * X2 * Y01 -
                FOUR * B * X0 * Y02 + ScalarType(10) * B * X1 * Y02 -
                FOUR * B * X2 * Y02 + FOUR * B * X0 * Y11 +
                FOUR * B * X2 * Y11 + ScalarType(10) * B * X0 * Y12 -
                FOUR * B * X1 * Y12 + ScalarType(14) * B * X2 * Y12 +
                FOUR * B * X0 * Y22 - ScalarType(14) * B * X1 * Y22),
         TWO * (-FIVE * X0Z1p + ScalarType(18) * X0Z1P + X0Z2 +
                SIX * A * X02 * X1 - FIVE * X1Z0 - SIX * X1Z1p - SIX * X1Z1P -
                FIVE * X1Z2 + X2Z0 - FIVE * X2Z1p + ScalarType(18) * X2Z1P -
                ScalarType(12) * B * X1 * Y01 + TWO * B * X2 * Y01 +
                TWO * B * X1 * Y02 + ScalarType(12) * B * X0 * Y11 +
                ScalarType(12) * B * X2 * Y11 + TWO * B * X0 * Y12 -
                ScalarType(12) * B * X1 * Y12),
         TWO * (X1Z1p - X1Z1P)});
    auto m1y_basis = std::array<ScalarType, 4>(
        {SIX *
             (-Y0Z0 + Y0Z2 + TWO * A * (X22 * Y0 + X00 * Y2 - X02 * (Y0 + Y2)) +
              Y2Z0 - Y2Z2),
         TWO *
             (FIVE * Y0Z0 + ScalarType(10) * Y0Z1p + SIX * Y0Z1P +
              ScalarType(7) * Y0Z2 + ScalarType(30) * B * Y02 * Y1 -
              ScalarType(11) * Y1Z0 - FOUR * Y1Z1p - ScalarType(11) * Y1Z2 +
              TWO * A *
                  (-TWO * X02 * Y0 + TWO * X11 * Y0 + FIVE * X12 * Y0 +
                   TWO * X22 * Y0 - ScalarType(7) * X00 * Y1 + FIVE * X02 * Y1 -
                   TWO * X12 * Y1 - ScalarType(7) * X22 * Y1 + TWO * X00 * Y2 -
                   TWO * X02 * Y2 + TWO * X11 * Y2 + ScalarType(7) * X12 * Y2 +
                   X01 * (ScalarType(7) * Y0 - TWO * Y1 + FIVE * Y2)) +
              ScalarType(7) * Y2Z0 + ScalarType(10) * Y2Z1p + SIX * Y2Z1P +
              FIVE * Y2Z2),
         -TWO * (FIVE * Y0Z1p - ScalarType(18) * Y0Z1P - Y0Z2 -
                 SIX * B * Y02 * Y1 + FIVE * Y1Z0 + SIX * Y1Z1p + SIX * Y1Z1P +
                 FIVE * Y1Z2 -
                 TWO * A *
                     (X12 * Y0 - SIX * X01 * Y1 + X02 * Y1 - SIX * X12 * Y1 +
                      X01 * Y2 + SIX * X11 * (Y0 + Y2)) -
                 Y2Z0 + FIVE * Y2Z1p - ScalarType(18) * Y2Z1P),
         TWO * (Y1Z1p - Y1Z1P)});
    auto m1z_basis = std::array<ScalarType, 5>(
        {-(AA * (ScalarType(21) * X0000 + ScalarType(28) * X000 * X2 +
                 ScalarType(30) * X00 * X22 + ScalarType(28) * X0 * X222 +
                 ScalarType(21) * X2222)) -
             ScalarType(21) * BB * Y0000 - ScalarType(28) * BB * Y000 * Y2 -
             ScalarType(30) * BB * Y00 * Y22 -
             TWO * AB *
                 (X00 * (ScalarType(21) * Y00 + ScalarType(14) * Y02 +
                         FIVE * Y22) +
                  TWO * X02 *
                      (ScalarType(7) * Y00 + ScalarType(10) * Y02 +
                       ScalarType(7) * Y22) +
                  X22 * (ScalarType(5) * Y00 + ScalarType(14) * Y02 +
                         ScalarType(21) * Y22)) -
             ScalarType(28) * BB * Y0 * Y222 - ScalarType(21) * BB * Y2222 +
             ScalarType(40) * Z00 + ScalarType(48) * Z02 + ScalarType(40) * Z22,
         THREE * AA *
                 (ScalarType(21) * X000 * X1 - ScalarType(7) * X00 * X11 -
                  ScalarType(10) * X02 * X11 + ScalarType(35) * X00 * X12 -
                  ScalarType(7) * X000 * X2 - ScalarType(10) * X00 * X22 +
                  ScalarType(35) * X01 * X22 - ScalarType(7) * X11 * X22 -
                  ScalarType(7) * X0 * X222 + ScalarType(21) * X1 * X222) -
             AB * (ScalarType(7) * X11 * Y00 - ScalarType(35) * X12 * Y00 +
                   ScalarType(10) * X22 * Y00 - ScalarType(63) * X00 * Y01 +
                   ScalarType(20) * X12 * Y01 - ScalarType(35) * X22 * Y01 +
                   ScalarType(21) * X00 * Y02 + ScalarType(10) * X11 * Y02 -
                   ScalarType(70) * X12 * Y02 + ScalarType(21) * X22 * Y02 +
                   ScalarType(7) * X00 * Y11 + ScalarType(7) * X22 * Y11 -
                   ScalarType(35) * X00 * Y12 + ScalarType(28) * X12 * Y12 -
                   ScalarType(63) * X22 * Y12 +
                   X01 * (-ScalarType(63) * Y00 + ScalarType(28) * Y01 -
                          ScalarType(70) * Y02 + ScalarType(20) * Y12 -
                          ScalarType(35) * Y22) +
                   ScalarType(10) * X00 * Y22 + ScalarType(7) * X11 * Y22 -
                   ScalarType(63) * X12 * Y22 +
                   X02 * (ScalarType(21) * Y00 - ScalarType(70) * Y01 +
                          ScalarType(40) * Y02 + ScalarType(10) * Y11 -
                          ScalarType(70) * Y12 + ScalarType(21) * Y22)) -
             THREE *
                 (BB *
                      (ScalarType(7) * Y00 * Y11 + ScalarType(10) * Y02 * Y11 -
                       ScalarType(35) * Y00 * Y12 +
                       ScalarType(7) * Y000 * (-THREE * Y1 + Y2) +
                       ScalarType(10) * Y00 * Y22 - ScalarType(35) * Y01 * Y22 +
                       ScalarType(7) * Y11 * Y22 + ScalarType(7) * Y0 * Y222 -
                       ScalarType(21) * Y1 * Y222) +
                  TWO * (ScalarType(5) * Z00 + ScalarType(10) * Z01p +
                         FOUR * Z02 - TWO * Z1p1p + ScalarType(10) * Z1p2 +
                         FIVE * Z22)),
         -SIX * AA *
                 (ScalarType(46) * X02 * X11 - ScalarType(14) * X0 * X111 +
                  X1111 - ScalarType(14) * X111 * X2 -
                  ScalarType(14) * X01 * X22 + ScalarType(28) * X11 * X22 +
                  X00 * (ScalarType(28) * X11 - ScalarType(14) * X12 + X22)) -
             TWO * AB *
                 (X22 * Y00 + ScalarType(112) * X01 * Y01 -
                  ScalarType(28) * X02 * Y01 - ScalarType(14) * X22 * Y01 -
                  ScalarType(28) * X01 * Y02 + FOUR * X02 * Y02 +
                  ScalarType(28) * X00 * Y11 - ScalarType(42) * X01 * Y11 +
                  ScalarType(46) * X02 * Y11 + ScalarType(28) * X22 * Y11 -
                  TWO * X12 *
                      (ScalarType(7) * Y00 - ScalarType(46) * Y01 +
                       ScalarType(14) * Y02 + ScalarType(21) * Y11 -
                       ScalarType(56) * Y12) -
                  ScalarType(14) * X00 * Y12 + ScalarType(92) * X01 * Y12 -
                  ScalarType(28) * X02 * Y12 + X00 * Y22 -
                  ScalarType(14) * X01 * Y22 +
                  X11 * (ScalarType(28) * Y00 - ScalarType(42) * Y01 +
                         ScalarType(46) * Y02 + SIX * Y11 -
                         ScalarType(42) * Y12 + ScalarType(28) * Y22)) +
             THREE *
                 (-TWO * BB *
                      (ScalarType(46) * Y02 * Y11 - ScalarType(14) * Y0 * Y111 +
                       Y1111 - ScalarType(14) * Y111 * Y2 -
                       ScalarType(14) * Y01 * Y22 + ScalarType(28) * Y11 * Y22 +
                       Y00 * (ScalarType(28) * Y11 - ScalarType(14) * Y12 +
                              Y22)) +
                  FIVE * Z00 + ScalarType(40) * Z01p - TWO * Z02 +
                  ScalarType(8) * Z1p1p + ScalarType(40) * Z1p2 + FIVE * Z22),
         -TWO * AA *
                 (ScalarType(3) * X02 * X11 - ScalarType(7) * X0 * X111 +
                  THREE * X1111 - ScalarType(7) * X111 * X2) -
             SIX * BB * Y02 * Y11 + ScalarType(14) * BB * Y0 * Y111 -
             SIX * BB * Y1111 -
             TWO * AB *
                 (ScalarType(2) * X12 * Y01 - ScalarType(7) * X01 * Y11 +
                  X02 * Y11 - ScalarType(7) * X12 * Y11 +
                  X11 * (-ScalarType(7) * Y01 + Y02 + SIX * Y11 -
                         ScalarType(7) * Y12) +
                  TWO * X01 * Y12) +
             ScalarType(14) * BB * Y111 * Y2 - FIVE * Z01p + Z02 -
             ScalarType(7) * Z1p1p - FIVE * Z1p2,
         -(AA * X1111) - TWO * AB * X11 * Y11 - BB * Y1111 + Z1p1p});
    for (size_t i = 0; i < 3; ++i) {
      moments.volume() += ReturnScalarType(coeffs[i] * m0_basis[i]);
    }
    for (size_t i = 0; i < 4; ++i) {
      moments.centroid()[0] += ReturnScalarType(coeffs[3 + i] * m1x_basis[i]);
      moments.centroid()[1] += ReturnScalarType(coeffs[3 + i] * m1y_basis[i]);
    }
    for (size_t i = 0; i < 5; ++i) {
      moments.centroid()[2] += ReturnScalarType(coeffs[7 + i] * m1z_basis[i]);
    }
    moments.volume() *= ReturnScalarType(area_proj_triangle);
    moments.centroid()[0] *= ReturnScalarType(area_proj_triangle);
    moments.centroid()[1] *= ReturnScalarType(area_proj_triangle);
    moments.centroid()[2] *= ReturnScalarType(area_proj_triangle);
    return moments;
  } else if constexpr (std::is_same_v<
                           ReturnType,
                           GeneralMomentsBase<2, 3, ReturnScalarType>>) {
    ParaboloidMomentArcIntegrator<ReturnType, ScalarType, 50> integrator(
        a_paraboloid, a_arc, a_face_normal, 3);
    return integrator.integrate();
  } else {
    std::cout << "Type 3 for moments with order > 2 not yet implemented"
              << std::endl;
    return ReturnType::fromScalarConstant(ReturnScalarType(0));
  }
}

template <class ReturnType, class ScalarType>
ReturnType computeFaceOnlyContribution(
    const AlignedParaboloidBase<ScalarType>& a_paraboloid,
    const PlaneBase<ScalarType>& a_face_plane,
    const PtBase<ScalarType>& a_pt_ref) {
  using ReturnScalarType = typename ReturnType::value_type;
  if constexpr (std::is_same_v<ReturnType, VolumeBase<ReturnScalarType>>) {
    /* Defining constants and types */
    const ScalarType EPSILON = machine_epsilon<ScalarType>();
    const ScalarType ZERO = ScalarType(0);
    const ScalarType FOUR = ScalarType(4);

    /* Function */
    assert(a_paraboloid.a() * a_paraboloid.b() > ZERO);
    assert(fabs(a_face_plane.normal()[2]) > EPSILON);
    const ScalarType a =
        -a_face_plane.normal()[0] / safelyEpsilon(a_face_plane.normal()[2]);
    const ScalarType b =
        -a_face_plane.normal()[1] / safelyEpsilon(a_face_plane.normal()[2]);
    const ScalarType c =
        a_face_plane.distance() / safelyEpsilon(a_face_plane.normal()[2]);
    const ScalarType factor = FOUR * a_paraboloid.a() * a_paraboloid.b() * c -
                              a_paraboloid.a() * b * b -
                              a_paraboloid.b() * a * a;
    return ReturnType::fromScalarConstant(ReturnScalarType(copysign(
        machine_pi<ScalarType>() * factor * factor /
            (ScalarType(32) *
             pow(a_paraboloid.a() * a_paraboloid.b(), ScalarType(2.5))),
        -a_face_plane.normal()[2])));
  } else if constexpr (std::is_same_v<ReturnType,
                                      VolumeMomentsBase<ReturnScalarType>>) {
    /* Defining constants and types */
    const ScalarType EPSILON = machine_epsilon<ScalarType>();
    const ScalarType ZERO = ScalarType(0);
    const ScalarType FOUR = ScalarType(4);
    const ScalarType FIVE = ScalarType(5);

    /* Function */
    assert(a_paraboloid.a() * a_paraboloid.b() > ZERO);
    assert(fabs(a_face_plane.normal()[2]) > EPSILON);
    const ScalarType a = -a_face_plane.normal()[0] / a_face_plane.normal()[2];
    const ScalarType b = -a_face_plane.normal()[1] / a_face_plane.normal()[2];
    const ScalarType c = a_face_plane.distance() / a_face_plane.normal()[2];
    const auto A = a_paraboloid.a(), B = a_paraboloid.b();
    auto moments = ReturnType::fromScalarConstant(ReturnScalarType(ZERO));
    const ScalarType factor = (a * a * B + A * (b * b - FOUR * B * c)) *
                              (a * a * B + A * (b * b - FOUR * B * c)) *
                              machine_pi<ScalarType>();
    moments.volume() = ReturnScalarType(
        copysign(factor / (ScalarType(32) * pow(A * B, ScalarType(2.5))),
                 -a_face_plane.normal()[2]));
    moments.centroid()[0] = ReturnScalarType(
        a * B *
        copysign(factor / (ScalarType(64) * pow(A * B, ScalarType(3.5))),
                 a_face_plane.normal()[2]));
    moments.centroid()[1] = ReturnScalarType(
        b * A *
        copysign(factor / (ScalarType(64) * pow(A * B, ScalarType(3.5))),
                 a_face_plane.normal()[2]));
    moments.centroid()[2] = ReturnScalarType(
        (FIVE * A * (b * b) + FIVE * (a * a) * B - ScalarType(8) * A * B * c) *
        copysign(factor / (ScalarType(384) * pow(A * B, ScalarType(3.5))),
                 a_face_plane.normal()[2]));
    return moments;
  } else if constexpr (std::is_same_v<
                           ReturnType,
                           GeneralMomentsBase<2, 3, ReturnScalarType>>) {
    /* Defining constants and types */
    const ScalarType EPSILON = machine_epsilon<ScalarType>();
    const ScalarType ZERO = ScalarType(0);
    const ScalarType TWO = ScalarType(2);
    const ScalarType FOUR = ScalarType(4);
    const ScalarType FIVE = ScalarType(5);
    const ScalarType SEVEN = ScalarType(7);

    /* Function */
    assert(a_paraboloid.a() * a_paraboloid.b() > ZERO);
    assert(fabs(a_face_plane.normal()[2]) > EPSILON);
    const ScalarType a = -a_face_plane.normal()[0] / a_face_plane.normal()[2];
    const ScalarType b = -a_face_plane.normal()[1] / a_face_plane.normal()[2];
    const ScalarType c = a_face_plane.distance() / a_face_plane.normal()[2];
    const auto A = a_paraboloid.a(), B = a_paraboloid.b();
    auto moments = ReturnType::fromScalarConstant(ReturnScalarType(ZERO));
    const ScalarType factor = (a * a * B + A * (b * b - FOUR * B * c)) *
                              (a * a * B + A * (b * b - FOUR * B * c)) *
                              machine_pi<ScalarType>();
    moments[0] = ReturnScalarType(
        copysign(factor / (ScalarType(32) * pow(A * B, ScalarType(2.5))),
                 -a_face_plane.normal()[2]));
    moments[1] = ReturnScalarType(
        a * B *
        copysign(factor / (ScalarType(64) * pow(A * B, ScalarType(3.5))),
                 a_face_plane.normal()[2]));
    moments[2] = ReturnScalarType(
        b * A *
        copysign(factor / (ScalarType(64) * pow(A * B, ScalarType(3.5))),
                 a_face_plane.normal()[2]));
    moments[3] = ReturnScalarType(
        (FIVE * A * (b * b) + FIVE * (a * a) * B - ScalarType(8) * A * B * c) *
        copysign(factor / (ScalarType(384) * pow(A * B, ScalarType(3.5))),
                 a_face_plane.normal()[2]));
    moments[4] = ReturnScalarType(
        (A * B * b * b + SEVEN * B * B * a * a - FOUR * A * B * B * c) *
        copysign(factor / (ScalarType(768) * pow(A * B, ScalarType(4.5))),
                 a_face_plane.normal()[2]));
    moments[5] = ReturnScalarType(
        (a * b) *
        copysign(factor / (ScalarType(128) * pow(A * B, ScalarType(3.5))),
                 a_face_plane.normal()[2]));
    moments[6] = ReturnScalarType(
        (B * B * a * a * a + A * B * a * b * b - TWO * A * B * B * a * c) *
        copysign(factor / (ScalarType(128) * pow(A * B, ScalarType(4.5))),
                 a_face_plane.normal()[2]));
    moments[7] = ReturnScalarType(
        (A * B * a * a + SEVEN * A * A * b * b - FOUR * A * A * B * c) *
        copysign(factor / (ScalarType(768) * pow(A * B, ScalarType(4.5))),
                 a_face_plane.normal()[2]));
    moments[8] = ReturnScalarType(
        (A * A * b * b * b + A * B * a * a * b - TWO * A * A * B * b * c) *
        copysign(factor / (ScalarType(128) * pow(A * B, ScalarType(4.5))),
                 a_face_plane.normal()[2]));
    moments[9] = ReturnScalarType(
        (SEVEN * A * A * b * b * b * b + TWO * SEVEN * A * B * a * a * b * b +
         SEVEN * B * B * a * a * a * a -
         ScalarType(24) * A * A * B * b * b * c -
         ScalarType(24) * A * B * B * a * a * c +
         ScalarType(16) * A * A * B * B * c * c) *
        copysign(factor / (ScalarType(1024) * pow(A * B, ScalarType(4.5))),
                 a_face_plane.normal()[2]));
    return moments;
  } else {
    std::cout << "Type 4 for moments with order > 2 not yet implemented"
              << std::endl;
    return ReturnType::fromScalarConstant(ReturnScalarType(0));
  }
}

template <class ReturnType, class ScalarType>
ReturnType computeTriangleCorrection(
    const AlignedParaboloidBase<ScalarType>& a_paraboloid,
    const PtBase<ScalarType>& a_pt_0, const PtBase<ScalarType>& a_pt_1,
    const PtBase<ScalarType>& a_pt_2) {
  using ReturnScalarType = typename ReturnType::value_type;
  if constexpr (std::is_same_v<ReturnType, VolumeBase<ReturnScalarType>>) {
    return ReturnType::fromScalarConstant(ReturnScalarType(
        (-a_paraboloid.a() * (a_pt_0[0] + a_pt_1[0]) * (a_pt_1[0] + a_pt_2[0]) +
         -a_paraboloid.b() * (a_pt_0[1] + a_pt_1[1]) * (a_pt_1[1] + a_pt_2[1]) -
         a_pt_0[2] - ScalarType(2) * a_pt_1[2] - a_pt_2[2]) /
        ScalarType(12) *
        ((a_pt_1[1] - a_pt_2[1]) * a_pt_0[0] +
         (a_pt_2[1] - a_pt_0[1]) * a_pt_1[0] +
         (a_pt_0[1] - a_pt_1[1]) * a_pt_2[0])));
    return ReturnType::fromScalarConstant(ReturnScalarType(0));
  } else if constexpr (std::is_same_v<ReturnType,
                                      VolumeMomentsBase<ReturnScalarType>>) {
    /* Defining constants and types */
    const ScalarType ZERO = ScalarType(0);
    const ScalarType ONE = ScalarType(1);
    const ScalarType TWO = ScalarType(2);
    const ScalarType THREE = ScalarType(3);
    const ScalarType FOUR = ScalarType(4);
    const ScalarType FIVE = ScalarType(5);
    const ScalarType SIX = ScalarType(6);
    const ScalarType HALF = ONE / TWO;

    /* Function */
    auto moments = ReturnType::fromScalarConstant(ReturnScalarType(ZERO));
    const ScalarType A = a_paraboloid.a(), B = a_paraboloid.b();
    const ScalarType X0 = a_pt_0[0], X1 = a_pt_1[0], X2 = a_pt_2[0];
    const ScalarType Y0 = a_pt_0[1], Y1 = a_pt_1[1], Y2 = a_pt_2[1];
    const ScalarType Z0 = a_pt_0[2], Z1 = a_pt_1[2], Z2 = a_pt_2[2];
    const ScalarType triangle_area =
        HALF * ((a_pt_1[1] - a_pt_2[1]) * a_pt_0[0] +
                (a_pt_2[1] - a_pt_0[1]) * a_pt_1[0] +
                (a_pt_0[1] - a_pt_1[1]) * a_pt_2[0]);
    moments.volume() = ReturnScalarType(
        (-a_paraboloid.a() * (a_pt_0[0] + a_pt_1[0]) * (a_pt_1[0] + a_pt_2[0]) +
         -a_paraboloid.b() * (a_pt_0[1] + a_pt_1[1]) * (a_pt_1[1] + a_pt_2[1]) -
         a_pt_0[2] - TWO * a_pt_1[2] - a_pt_2[2]) *
        triangle_area / SIX);
    moments.centroid()[0] = ReturnScalarType(
        triangle_area *
        ((A * (-(X0 * X0 * X0) - X1 * X1 * X1 - X1 * X1 * X2 - X1 * (X2 * X2) -
               X2 * X2 * X2 - X0 * X0 * (X1 + X2) -
               X0 * (X1 * X1 + X1 * X2 + X2 * X2))) /
             ScalarType(10) +
         (B * (-(X1 * (Y0 * Y0 + TWO * Y0 * Y1 + THREE * (Y1 * Y1) + Y0 * Y2 +
                       TWO * Y1 * Y2 + Y2 * Y2)) -
               X2 * (Y0 * Y0 + Y0 * Y1 + Y1 * Y1 + TWO * Y0 * Y2 +
                     TWO * Y1 * Y2 + THREE * (Y2 * Y2)) -
               X0 * (THREE * (Y0 * Y0) + Y1 * Y1 + Y1 * Y2 + Y2 * Y2 +
                     TWO * Y0 * (Y1 + Y2)))) /
             ScalarType(30) +
         (-(X0 * (TWO * Z0 + Z1 + Z2)) - X1 * (Z0 + TWO * Z1 + Z2) -
          X2 * (Z0 + Z1 + TWO * Z2)) /
             ScalarType(12)));
    moments.centroid()[1] = ReturnScalarType(
        -triangle_area *
        ((B * (Y0 * Y0 * Y0 + Y1 * Y1 * Y1 + Y1 * Y1 * Y2 + Y1 * (Y2 * Y2) +
               Y2 * Y2 * Y2 + Y0 * Y0 * (Y1 + Y2) +
               Y0 * (Y1 * Y1 + Y1 * Y2 + Y2 * Y2))) /
             ScalarType(10) +
         (A *
          (X0 * X0 * (THREE * Y0 + Y1 + Y2) + X1 * X1 * (Y0 + THREE * Y1 + Y2) +
           X2 * X2 * (Y0 + Y1 + THREE * Y2) + X1 * X2 * (Y0 + TWO * (Y1 + Y2)) +
           X0 * (X1 * (TWO * Y0 + TWO * Y1 + Y2) +
                 X2 * (TWO * Y0 + Y1 + TWO * Y2)))) /
             ScalarType(30) +
         (Y0 * (TWO * Z0 + Z1 + Z2) + Y1 * (Z0 + TWO * Z1 + Z2) +
          Y2 * (Z0 + Z1 + TWO * Z2)) /
             ScalarType(12)));
    moments.centroid()[2] = ReturnScalarType(
        triangle_area *
        ((A * A *
          (X0 * X0 * X0 * X0 + X1 * X1 * X1 * X1 + X1 * X1 * X1 * X2 +
           X1 * X1 * (X2 * X2) + X1 * (X2 * X2 * X2) + X2 * X2 * X2 * X2 +
           X0 * X0 * X0 * (X1 + X2) + X0 * X0 * (X1 * X1 + X1 * X2 + X2 * X2) +
           X0 *
               (X1 * X1 * X1 + X1 * X1 * X2 + X1 * (X2 * X2) + X2 * X2 * X2))) /
             ScalarType(30) +
         (B * B *
          (Y0 * Y0 * Y0 * Y0 + Y1 * Y1 * Y1 * Y1 + Y1 * Y1 * Y1 * Y2 +
           Y1 * Y1 * (Y2 * Y2) + Y1 * (Y2 * Y2 * Y2) + Y2 * Y2 * Y2 * Y2 +
           Y0 * Y0 * Y0 * (Y1 + Y2) + Y0 * Y0 * (Y1 * Y1 + Y1 * Y2 + Y2 * Y2) +
           Y0 *
               (Y1 * Y1 * Y1 + Y1 * Y1 * Y2 + Y1 * (Y2 * Y2) + Y2 * Y2 * Y2))) /
             ScalarType(30) +
         (A * B *
          (X1 * X2 *
               (Y0 * Y0 + THREE * (Y1 * Y1) + FOUR * Y1 * Y2 +
                THREE * (Y2 * Y2) + TWO * Y0 * (Y1 + Y2)) +
           X0 * X0 *
               (SIX * (Y0 * Y0) + Y1 * Y1 + Y1 * Y2 + Y2 * Y2 +
                THREE * Y0 * (Y1 + Y2)) +
           X1 * X1 *
               (Y0 * Y0 + SIX * (Y1 * Y1) + THREE * Y1 * Y2 + Y2 * Y2 +
                Y0 * (THREE * Y1 + Y2)) +
           X2 * X2 *
               (Y0 * Y0 + Y1 * Y1 + THREE * Y1 * Y2 + SIX * (Y2 * Y2) +
                Y0 * (Y1 + THREE * Y2)) +
           X0 * (X1 * (THREE * (Y0 * Y0) + FOUR * Y0 * Y1 + THREE * (Y1 * Y1) +
                       TWO * Y0 * Y2 + TWO * Y1 * Y2 + Y2 * Y2) +
                 X2 * (THREE * (Y0 * Y0) + TWO * Y0 * Y1 + Y1 * Y1 +
                       FOUR * Y0 * Y2 + TWO * Y1 * Y2 + THREE * (Y2 * Y2))))) /
             ScalarType(90) +
         (-(Z0 * Z0) - Z1 * Z1 - Z1 * Z2 - Z2 * Z2 - Z0 * (Z1 + Z2)) /
             ScalarType(12)));
    return moments;
  } else if constexpr (std::is_same_v<
                           ReturnType,
                           GeneralMomentsBase<2, 3, ReturnScalarType>>) {
    return ReturnType::fromScalarConstant(ReturnScalarType(0));
  } else {
    std::cout << "Type 5 for moments with order > 2 not yet implemented"
              << std::endl;
    return ReturnType::fromScalarConstant(ReturnScalarType(0));
  }
}

}  // namespace IRL

#endif  // IRL_GENERIC_CUTTING_PARABOLOID_INTERSECTION_MOMENT_CONTRIBUTIONS_TPP_
